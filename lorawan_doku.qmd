---
title: "LoraWan Doku"
subtitle: "version 0.1"
author: "Chris Reudenbach"
format:
  html:
    theme: cosmo
    toc: true
    toc-depth: 3
    number-sections: true      
    number-depth: 3           

    code-copy: true
    code-link: true
    code-overflow: wrap
    code-fold: true
    highlight-style: github
execute:
  mermaid: true
diagram:
  mermaid:
    engine: kroki
    kroki-url: https://kroki.io
---

Hier folgt eine basale Anleitung fÃ¼r den Betrieb eines MikroTik-LoRaWAN-Gateways (RBwAPR-2nD) Ã¼ber WLAN mit TTN (EU1) sowie der Einbindung der Sensoren **Dragino PS-LB**, **Dragino DDS-75LB** und **Seeed SenseCAP S2120**. Die **konkreten Decoder** sind nicht enthalte aber auf dem Gateway bereits aktiv. ZusÃ¤tzlich werden praxistaugliche Wege zum **Dauerbetrieb** (Storage, MQTTâ†’CSV/DB, InfluxDB/Grafana) und **No-Code-Speicherung** (Webhooks) skizziert. Beispiele und Snippets sind so gehalten, dass sie direkt Ã¼bernommen werden kÃ¶nnen.

---

# Kurzanleitung

## Script hochladen

* In **WinBox â†’ Files**: [Setup-Datei `gisma_base2.rsc`](src/gisma_base2.rsc) einfach per Drag\&Drop auf das GerÃ¤t laden. [**WinBox Download (MikroTik)**](https://mikrotik.com/download)

## Script importieren

* In **WinBox â†’ New Terminal** ausfÃ¼hren:

```bash
  /import file-name=gisma_base2.rsc
```

## Funktion testen

* WLAN/DHCP:

```bash
  /interface wireless monitor wlan1 once
  /ip dhcp-client print detail
  /ping 8.8.8.8 count=4
```
* LoRa (falls enthalten):

```bash
  /lora print detail
  /tool sniffer quick port=1700
```


## Grundlagen MikroTik-KonnektivitÃ¤t, MAC-Zugriff und Hotspot-Einstellungen

### Hardware-Aufbau
- MikroTik RBwAPR-2nD mit Netzteil/PoE versorgen.
- Ethernet vom **PC/Laptop** an **ether1** des MikroTik stecken.
- Optional: LoRa-Antenne montieren und fest verschrauben.

### Erstverbindung per WinBox (Layer-2 / MAC)
- WinBox starten â†’ **Neighbors**: RBwAPR sollte automatisch erscheinen.
- Verbinden Ã¼ber **MAC Address** (funktioniert ohne IP).
- Login: ab Werk `admin` (ggf. ohne Passwort) â†’ bei erster Anmeldung Passwort setzen.
- Bei Ã¤lteren QuickSet-Resten: **System â†’ Reset Configuration** (ohne Default-Skripte), danach erneut per MAC verbinden.

### Hotspot-/WLAN-Voraussetzungen
- **Band**: 2,4 GHz (802.11b/g/n). Station-Pseudobridge ist bei 5 GHz oft nicht zuverlÃ¤ssig.
- **Sicherheitsmodus**: WPA2-PSK (empfohlen), Kennwort ohne SonderfÃ¤lle.
- **SSID**: sichtbar, statischer Name (keine Auto-Umschaltung).
- **Kanalbreite**: 20 MHz genÃ¼gt; Auto-Kanal ist ok.
- **Captive Portal**: deaktivieren. Portale blockieren Headless-GerÃ¤te.
- **MAC-Filter**: falls aktiv, MAC von `wlan1` freigeben (siehe **Interfaces â†’ wlan1**).
- **DHCP** am Hotspot: aktiv, ausreichend Adressbereich (z. B. 192.168.1.100â€“200).
- **Internet-Durchleitung** (NAT) im Hotspot aktiv lassen.

### WLAN-Client (GUI-Weg, WinBox)
1. **Wireless â†’ Security Profiles**  
   - WPA2-PSK mit Kennwort anlegen/Ã¤ndern.
2. **Wireless â†’ wlan1**  
   - Mode: `station-pseudobridge`  
   - Band: `2ghz-b/g/n`  
   - SSID: Hotspot-SSID eintragen  
   - **Apply**, dann **Enable**.
3. **Bridge**  
   - **Bridge â†’ +** `bridgeLocal` anlegen.  
   - **Bridge â†’ Ports**: `wlan1` **und** `ether1` zur `bridgeLocal` hinzufÃ¼gen.
4. **DHCP-Client**  
   - **IP â†’ DHCP Client â†’ +**  
     - Interface: `bridgeLocal`, **Enabled**.
5. **DNS** (optional)  
   - **IP â†’ DNS**: Public Resolver (z. B. `8.8.8.8`, `1.1.1.1`), â€žAllow Remote Requestsâ€œ aktivieren.

### Kontrolle & Umstieg auf IP-Zugriff
- **IP-Bezug prÃ¼fen**: **IP â†’ DHCP Client** zeigt â€žboundâ€œ mit zugewiesener IP.
- **Routing/Internet** testen: **New Terminal** â†’ `/ping 8.8.8.8 count=4`
- Danach in WinBox statt Ã¼ber **MAC** Ã¼ber die **IP** verbinden (stabiler, schneller).

### Tests (Terminal, minimal)

```bash
/interface wireless monitor wlan1 once
/ip dhcp-client print detail
/ping 8.8.8.8 count=4
/ip route print
/ip dns print
```


ðŸ‘‰ Damit ist die Konfiguration in einem Rutsch aufgespielt.


# Langversion

## Topologie und Begriffe

KurzÃ¼berblick Ã¼ber alle Bausteine (Sensoren, Gateway, Netzwerk, TTN, Decoder) und wie sie zusammenspielen. Begriffe werden so eingefÃ¼hrt, dass die folgenden Schritte leichter nachvollziehbar sind.

### Gesamtbild

Eine End-to-End-Skizze vom Sensor (LoRaWAN) bis zur Datennutzung (Speicher/Visualisierung). Hilft, die Rolle jeder Komponente zu verstehen.

```{mermaid, fig-align="center", fig-width=4, fig-height=3}
%%{init: {'themeVariables': { 'fontSize': '12px' }}}%%
flowchart TB
  A["Sensor<br/>(LoRaWAN, EU868)"]
  B["LoRa-Gateway<br/>MikroTik RBwAPR-2nD"]
  C["WLAN-Hotspot<br/>(Internet)"]
  D["TTN (EU1)"]
  E["Decoder<br/>(in TTN Application)"]
  F["Ablage / Visualisierung<br/>(Storage / MQTT / DB / Grafana / No-Code)"]
  A --> B --> C --> D --> E --> F

```

### MikroTik als WLAN-Client

Der MikroTik wird als WLAN-Station betrieben, nicht als Access Point. So hÃ¤ngt er sich in ein vorhandenes WLAN ein und leitet LoRaWAN-Pakete ins Internet.

* Der MikroTik arbeitet **nicht** als Access Point, sondern als **Station** im WLAN (vergleichbar mit einem Laptop).
* Der Modus **station-pseudobridge** sorgt dafÃ¼r, dass WLAN und Ethernet im selben Layer-2-Segment erscheinen (Broadcast-Domain geteilt).

### Bridge (bridgeLocal)

Eine Layerâ€‘2â€‘Bridge, die `wlan1` und `ether1` zu einem logischen Switch verbindet. Der DHCP-Client sitzt auf der Bridge, damit die IP fÃ¼r beide Ports gilt.

* Die **Bridge** bÃ¼ndelt Interfaces zu einem logischen Switch (hier: `wlan1` + `ether1`).
* **DHCP-Client** hÃ¤ngt auf der Bridge und bezieht die IP vom Hotspot.

### â€žAlte Resteâ€œ

Werkseinstellungen/QuickSet legen oft Regeln an, die im Client-Betrieb stÃ¶ren. Dieser Abschnitt erklÃ¤rt, was entfernt bzw. nicht benÃ¶tigt wird.

* Werkseinstellungen/QuickSet hinterlassen oft DHCP-Server/NAT/Firewall-Regeln, die im Client-Betrieb stÃ¶ren kÃ¶nnen.
* Nach Reset wird nur das **NÃ¶tige** konfiguriert (WLAN-Client, Bridge, DHCP-Client, DNS).

### Sensoren/Decoder (ohne Details)

Ãœberblick, welche GerÃ¤te eingebunden werden und wo deren Decoder liegen (TTN Application oder per Device-Override).

* **Dragino PS-LB** und **Dragino DDS-75LB** werden identisch (OTAA) aufgenommen; **Decoder unterscheiden sich**, sind aber **in der TTN-Application bereits aktiv**.
* **SenseCAP S2120** nutzt proprietÃ¤re Payloads (typisch **FPort 199**); der **Decoder ist in der Application hinterlegt**.
* Verwaltung: **Application â†’ Payload formatters (Uplink)**; auf Wunsch **device-spezifisch** via Device-Override.

---

## MikroTik â€“ Soll-Konfiguration (WLAN & Bridge & LoRa)

Schrittâ€‘fÃ¼râ€‘Schrittâ€‘Konfiguration des MikroTik: WLAN-Client, Bridge, IP/DNS und LoRaâ€‘Gatewayâ€‘Weiterleitung zu TTN EU1.

> Die folgenden Snippets setzen die bekannte funktionierende Basis um (WLAN-Client auf SSID â€žGISMA-NETâ€œ, WPA2-PSK, Pseudobridge, TTN EU1/UDP, EU-868).

### WLAN-Security

Sicherheitsprofil fÃ¼r WPA/WPA2â€‘PSK. Hinterlegt SchlÃ¼ssel und Cipher.

```bash
/interface wireless security-profiles set [find default=yes] \
    mode=dynamic-keys \
    authentication-types=wpa-psk,wpa2-psk \
    unicast-ciphers=tkip,aes-ccm \
    group-ciphers=tkip,aes-ccm \
    supplicant-identity=MikroTik \
    wpa-pre-shared-key=36171669 \
    wpa2-pre-shared-key=36171669
```

### WLAN als Client (Pseudobridge)

Versetzt `wlan1` in den Stationâ€‘Modus mit Pseudobridge, um im gleichen Layerâ€‘2 wie der Hotspot zu sein.

```bash
/interface wireless set [find default-name=wlan1] \
    band=2ghz-b/g/n \
    wireless-protocol=802.11 \
    mode=station-pseudobridge \
    ssid=GISMA-NET \
    frequency=auto \
    disabled=no
```

### Bridge + Ports

Erstellt `bridgeLocal` und fÃ¼gt `wlan1` und `ether1` als Ports hinzu.

```bash
/interface bridge add name=bridgeLocal
/interface bridge port add bridge=bridgeLocal interface=wlan1
/interface bridge port add bridge=bridgeLocal interface=ether1
```

### IP-Bezug & DNS

Aktiviert einen DHCPâ€‘Client auf der Bridge und setzt Resolver fÃ¼r DNS.

```bash
/ip dhcp-client add interface=bridgeLocal disabled=no
/ip dns set allow-remote-requests=yes servers=8.8.8.8,1.1.1.1
```

### LoRa â€“ TTN EU1 (Semtech UDP) & EU-868

Aktiviert das eingebaute LoRaâ€‘Gateway, stellt EUâ€‘868 ein und konfiguriert den Semtechâ€‘UDPâ€‘Forwarder zu TTN EU1.

```bash
/lora disable 0
/lora set 0 servers="TTN V3 (eu1)" channel-plan=eu-868 \
    network=public forward=crc-valid,crc-error
/lora enable 0
```

**PrÃ¼fung:**

Schnelle Checks: LoRaâ€‘Status und ob UDPâ€‘Pakete auf Port 1700 rausgehen.

```bash
/lora print detail
/tool sniffer quick port=1700
```

---

## WinBox/Terminal â€“ Diagnoseleitfaden

Sammlung typischer Diagnoseâ€‘Befehle, um WLAN, IPâ€‘Vergabe, Routing und LoRaâ€‘Weiterleitung zu prÃ¼fen.

### WLAN & IP

Befehle zum Scannen/Ãœberwachen des WLANs und zum PrÃ¼fen der IPâ€‘Konfiguration/KonnektivitÃ¤t.

* WLAN-Scan:

```bash
  /interface wireless scan wlan1
```
* Monitor des Clients (Status, Kanal, Rauschpegel):
```bash
  /interface wireless monitor wlan1
```
* DHCP-Client-Status:

```bash
  /ip dhcp-client print detail
```

* Routing:

```bash
  /ip route print
```
* KonnektivitÃ¤tstest:

```bash
  /ping 8.8.8.8
```

### Bridge/Ports

Druckt Bridge und Portâ€‘ZugehÃ¶rigkeiten, um Fehlverdrahtungen auszuschlieÃŸen.

```bash
/interface bridge print
/interface bridge port print
```

### LoRa-Gateway

PrÃ¼ft LoRaâ€‘Gatewayâ€‘Parameter (EUI, Server, Plan) und ob Forwarderâ€‘Traffic sichtbar ist.

* Status/EUI/Server/Plan:

```bash
  /lora print detail
```
* UDP-Forwarding sichtbar?

```bash
  /tool sniffer quick port=1700
```

### Export/Sicherung

Exportiert die Konfiguration textuell (Backup der Einstellungen) bzw. erstellt ein binÃ¤res Vollâ€‘Backup.

* Terse-Export (menschenlesbar):

```bash
  /export terse
```
* Binary-Backup (voll):

```bash
  /system backup save name=running.backup
```

---

## TTN-Konsole â€“ Gateway, Application, GerÃ¤te

Schritte in der TTNâ€‘Konsole: Gateway registrieren, Application anlegen, GerÃ¤te per OTAA hinzufÃ¼gen und Decoder prÃ¼fen.

### Gateway

Registrierung des Gateways in TTN inkl. Cluster und Frequencyâ€‘Plan.

* Registrierung mit **Gateway-EUI** (siehe `/lora print detail`).
* **Cluster**: `eu1.cloud.thethings.network`.
* **Frequency Plan**: EU\_863\_870\_TTN.

### Application & GerÃ¤te (OTAA)

GerÃ¤te anlegen (OTAAâ€‘Daten), Decoder aktivieren/prÃ¼fen und Liveâ€‘Daten kontrollieren.

* Application (z. B. `gisma-hydro-testbed`) vorhanden.
* GerÃ¤te hinzufÃ¼gen (PS-LB, DDS-75LB, S2120): **DevEUI**, **JoinEUI/AppEUI**, **AppKey** (jeweils 16 Byte Hex).
* **Decoder** sind **aktiv** (Application-Ebene bzw. Device-Override).
* Kontrolle unter **End device â†’ Live data**: Uplinks sichtbar, `decoded_payload` gefÃ¼llt.



:::{.callout-note title="Datenablage â€“ einfache Wege ohne eigenen Server" collapse="true"}


## Datenablage â€“ einfache Wege ohne eigenen Server

Drei niedrigschwellige Optionen, um Daten ohne eigene Serverâ€‘Software zu speichern (Storage, MQTTâ†’Datei, Webhooks).

### TTS-Storage (eingebaut, â€œkein Server nÃ¶tigâ€)

TTNâ€‘interner Speicher mit einfachem HTTPâ€‘Abruf (NDJSON). Ideal fÃ¼r erste Tests/Archivierung.

**Aktivierung:** Application â†’ **Integrations â†’ Storage** â†’ Enable.

**Abruf (NDJSON):**

```bash
APP_ID="gisma-hydro-testbed"
REGION="eu1"
API_KEY="NNSXS.***api_key***"

curl -s -H "Authorization: Bearer $API_KEY" \
"https://${REGION}.cloud.thethings.network/api/v3/as/applications/${APP_ID}/packages/storage/uplink_message?limit=100" \
> uplinks.ndjson
```

**Nach CSV destillieren (allgemein):**

```bash
jq -r '
  .end_device_ids.device_id as $id
  | .received_at as $ts
  | .uplink_message.f_port as $fport
  | (.uplink_message.decoded_payload // {}) as $dec
  | [$ts,$id,$fport,($dec|tostring)]
  | @csv
' uplinks.ndjson > uplinks.csv
```

**Hinweis:** Speicherfrist je nach Tarif begrenzt â†’ regelmÃ¤ÃŸig abholen.

### MQTT â†’ Datei/CSV (ohne Programmierung)

Abonnieren des TTNâ€‘MQTTâ€‘Feeds und direkte Umwandlung in CSV mit `jq`.

**Abonnieren:**

```bash
APP_ID="gisma-hydro-testbed"
REGION="eu1"
API_KEY="NNSXS.***api_key***"

mosquitto_sub -h "${REGION}.cloud.thethings.network" -p 8883 \
  -u "${APP_ID}" -P "${API_KEY}" --cafile /etc/ssl/certs/ca-certificates.crt \
  -t "v3/${APP_ID}@ttn/devices/+/up" > live.ndjson
```

**On-the-fly CSV:**

```bash
mosquitto_sub ... | jq -r '
  .end_device_ids.device_id as $id
  | .received_at as $ts
  | .uplink_message.f_port as $fport
  | (.uplink_message.decoded_payload // {}) as $dec
  | [$ts,$id,$fport,($dec|tostring)]
  | @csv
' >> live.csv
```

### No-Code via Webhooks

Weiterleitung der Uplinks per HTTP an Dienste wie Make.com, n8n oder Zapier, die ohne Programmierung in Tabellen/DBs schreiben.

* Application â†’ **Integrations â†’ Webhooks â†’ Add** â†’ â€žCustomâ€œ oder Vorlage.
* Ziel-URL eines **Make.com**, **n8n Cloud** oder **Zapier** Flows eintragen.
* JSON in **Google Sheets**, **Airtable**, **Notion** oder **S3**/Datenbank speichern.

---

## Dauerbetrieb â€“ robuste Pipelines (MQTTâ†’DB, Grafana)

Produktionsreife Wege, um kontinuierlich Daten zu sammeln, in eine Zeitreihendatenbank zu schreiben und mit Grafana zu visualisieren.

### Minimal-Python (MQTTâ†’CSV/JSON)

Kleines Pythonâ€‘Skript mit `paho-mqtt`, das Uplinks liest und als CSV/JSON speichert.

```python
# mqtt_to_csv.py
import ssl, json, csv
from paho.mqtt.client import Client

APP_ID  = "gisma-hydro-testbed"
REGION  = "eu1"
API_KEY = "NNSXS.***api_key***"
TOPIC   = f"v3/{APP_ID}@ttn/devices/+/up"
BROKER  = f"{REGION}.cloud.thethings.network"

def on_connect(c,u,f,rc):
    c.subscribe(TOPIC, qos=0)

def on_message(c,u,msg):
    up = json.loads(msg.payload.decode())
    ts  = up.get("received_at")
    dev = up.get("end_device_ids",{}).get("device_id")
    fpt = up.get("uplink_message",{}).get("f_port")
    dec = up.get("uplink_message",{}).get("decoded_payload", {})
    with open("uplinks.csv","a",newline="") as f:
        csv.writer(f).writerow([ts,dev,fpt,json.dumps(dec,ensure_ascii=False)])

cli = Client(client_id=APP_ID)
cli.username_pw_set(APP_ID, API_KEY)
cli.tls_set(cert_reqs=ssl.CERT_REQUIRED)
cli.on_connect = on_connect
cli.on_message = on_message
cli.connect(BROKER, 8883, keepalive=60)
cli.loop_forever()
```

Start:

```bash
pip install paho-mqtt
python mqtt_to_csv.py
```

### InfluxDB v2 + Grafana (Docker-Variante)

Stack aus InfluxDB (Zeitreihendatenbank), Telegraf (Ingest/Parsing) und Grafana (Dashboards) als Dockerâ€‘Compose.

**docker-compose.yml (Beispiel, lokal)**

```yaml
version: "3.8"
services:
  influxdb:
    image: influxdb:2
    ports: [ "8086:8086" ]
    volumes: [ "influx:/var/lib/influxdb2" ]
    environment:
      - DOCKER_INFLUXDB_INIT_MODE=setup
      - DOCKER_INFLUXDB_INIT_USERNAME=admin
      - DOCKER_INFLUXDB_INIT_PASSWORD=adminpass
      - DOCKER_INFLUXDB_INIT_ORG=gisma
      - DOCKER_INFLUXDB_INIT_BUCKET=lorawan
  telegraf:
    image: telegraf:1.29
    depends_on: [ influxdb ]
    volumes:
      - ./telegraf.conf:/etc/telegraf/telegraf.conf:ro
  grafana:
    image: grafana/grafana:10
    ports: [ "3000:3000" ]
    volumes: [ "grafana:/var/lib/grafana" ]
volumes:
  influx:
  grafana:
```

**telegraf.conf (MQTTâ†’InfluxDB Line Protocol)**

```toml
[agent]
  omit_hostname = true

# TTN MQTT input
[[inputs.mqtt_consumer]]
  servers = ["ssl://eu1.cloud.thethings.network:8883"]
  topics  = ["v3/gisma-hydro-testbed@ttn/devices/+/up"]
  username = "gisma-hydro-testbed"
  password = "NNSXS.***api_key***"
  data_format = "json"
  json_time_key = "received_at"
  json_time_format = "2006-01-02T15:04:05Z07:00"
  # Felder extrahieren
  json_string_fields = ["uplink_message.decoded_payload"]

  # Umformung per tagexclude/fieldpass kann nach Bedarf ergÃ¤nzt werden

# InfluxDB v2 output
[[outputs.influxdb_v2]]
  urls = ["http://influxdb:8086"]
  token = "admin:adminpass"      # bei Influx v2 Setup eigenen Token verwenden
  organization = "gisma"
  bucket = "lorawan"
```

**Grafana:**

Visualisierungsschicht. In Grafana die InfluxDBâ€‘Datenquelle setzen und Panels fÃ¼r relevante Messreihen anlegen.

* Datenquelle **InfluxDB v2** auf `http://influxdb:8086`, Org/Bucket/Token setzen.
* Dashboard erstellen; z. B. Messungen `pressure_cmH2O`, `distance_cm`, `battery`, `temperature` (abhÃ¤ngig von Decoderfeldern in `decoded_payload`).
* Alternativ: **TTN â†’ InfluxDB Cloud** per **Webhook-Vorlage** (Konsole â†’ Integrations â†’ Webhooks â†’ InfluxDB Cloud).

:::

---

## Betriebshilfen (Auto-Heal, Checks)

Zusatzfunktionen fÃ¼r stabilen Dauerbetrieb: automatischer WLANâ€‘Reconnect und korrekte Systemzeit.

### Netwatch (WLAN neu verbinden bei Ausfall)

Ãœberwacht einen Zielhost und startet `wlan1` neu, wenn keine Verbindung besteht.

```bash
/tool netwatch add host=8.8.8.8 interval=60s timeout=5s \
    up-script="" \
    down-script="/interface wireless disable wlan1; :delay 2s; /interface wireless enable wlan1"
```

### NTP & Zeitzone (Logs mit korrekter Uhrzeit)

Stellt Zeitzone und NTPâ€‘Server ein, damit Logs/Zeitstempel stimmen.

```bash
/system clock set time-zone-name=Europe/Berlin
/system ntp client set enabled=yes primary-ntp=1.1.1.1 secondary-ntp=8.8.8.8
```

---

## SenseCAP-Besonderheiten (ohne Decoder-Code)

Hinweise zu Pairing, FPorts und Decoderâ€‘Einsatz fÃ¼r den SenseCAP S2120.

* **Pairing/BT-PIN:** hÃ¤ufig `000000`.
* **DevEUI/JoinEUI/AppKey:** auf Label, App oder Herstellerportal.
* **FPort:** typischerweise **199**.
* In TTN **GerÃ¤t anlegen** (OTAA) â†’ **Live Data** prÃ¼fen â†’ **decoded\_payload** wird angezeigt (Decoder **ist bereits aktiv**).
* Bei fehlender Decodierung: Application-Level Decoder prÃ¼fen; falls mehrere Hersteller parallel verwendet werden, **device-spezifische Overrides** setzen.

---

## Dragino PS-LB & DDS-75LB (ohne Decoder-Code)

Kurzanleitung fÃ¼r die Aufnahme per OTAA und Decoderâ€‘Kontrolle der Draginoâ€‘GerÃ¤te.

* Beide Ã¼ber OTAA identisch aufnehmen (DevEUI/JoinEUI/AppKey).
* **Decoder unterscheiden sich** (Druck vs. Distanz) â€“ **bereits aktiv**.
* Kontrolle via Live Data; Werte erscheinen im `decoded_payload`.
* Typischer **FPort 2** (Herstellerdoku beachten).

---

## FAQs & Troubleshooting 

Kurze Checkliste typischer Fehlerbilder und ihrer Ursachen.

* **Uplinks kommen nicht in TTN an:**
  `/lora print detail` (Enabled?), `/tool sniffer quick port=1700` (UDP-Traffic?), `/ip dhcp-client print` (IP bekommen?), `/ping 8.8.8.8`.

* **WLAN sichtbar, aber keine IP:**
  Bridge-Ports korrekt? DHCP-Client auf **bridgeLocal**? WPA-Key/SSID korrekt? `monitor wlan1` zeigt â€žsearching-for-networkâ€œ â†’ Kanal/Entfernung prÃ¼fen.

* **Decoder greift nicht:**
  FPort prÃ¼fen; Application-Decoder vs. Device-Override; fÃ¼r SenseCAP meist Port 199.

* **Speicherung/Visualisierung fehlt:**
  Storage aktivieren **oder** MQTTâ†’CSV/DB/Grafana implementieren (siehe Kapitel 5 & 6).

---

### To-Do-Leitfaden

Minimalliste, um schnell von â€žGerÃ¤t onlineâ€œ zu â€žDaten gesichert und sichtbarâ€œ zu kommen.

1. **TTN Storage aktivieren** und per **HTTP + jq** regelmÃ¤ÃŸig ziehen (Archiv/CSV).
2. FÃ¼r Live-Dashboards **MQTT â†’ InfluxDB â†’ Grafana** (Docker-Stack) oder **Webhook â†’ InfluxDB Cloud**/**Datacake**/**Ubidots**.
3. **Netwatch** auf dem MikroTik setzen (WLAN-Selbstheilung).
4. Binary-Backup auf dem MikroTik anlegen und extern sichern.

---

## **Anmerkungen**

ErgÃ¤nzende Hinweise zur Konfiguration und zum Betrieb (EUâ€‘868, Semtechâ€‘UDP, Datenpfade) in kompakter Form.

* Die **Decoder fÃ¼r PS-LB, DDS-75LB und SenseCAP S2120** sind in der TTN-Application **hinterlegt und aktiv**.
* Der **MikroTik** arbeitet im **WLAN-Client/Pseudobridge-Modus**, erhÃ¤lt IP per **DHCP** auf `bridgeLocal` und **forwardet LoRa-Pakete** via **Semtech-UDP (Port 1700)** an **TTN EU1** mit **EU-868** Frequency-Plan.
* Daten kÃ¶nnen Ã¼ber **Storage/MQTT/Webhook** ohne eigenen Server gespeichert und mit **Grafana** visualisiert werden.

## Downloads & HandbÃ¼cher

- [**WinBox Download (MikroTik)**](https://mikrotik.com/download)  
  Offizielle Seite zum Herunterladen von WinBox (Windows/Linux mit Wine).

- [**MikroTik RouterOS LoRa Dokumentation**](https://help.mikrotik.com/docs/display/ROS/LoRa)  
  MikroTik-Doku zu LoRaWAN, Forwarding-Protokoll und Frequency Plans.

---

- [**Dragino Wiki (Ãœbersicht)**](https://wiki.dragino.com/xwiki/bin/view/Main/)  
  Zentrale Dokumentation und Manuals fÃ¼r alle Dragino-GerÃ¤te.

- [**Dragino Decoder Repository (GitHub)**](https://github.com/dragino/dragino-end-node-decoder/tree/main)  
  Sammlung offizieller Payload-Decoder fÃ¼r End-Nodes (z. B. PS-LB, DDS-75LB).

---

- [**Seeed SenseCAP S2120 Getting Started (Wiki)**](https://wiki.seeedstudio.com/Getting_Started_with_SenseCAP_S2120_8-in-1_LoRaWAN_Weather_Sensor/)  
  Schritt-fÃ¼r-Schritt-Anleitung zur Inbetriebnahme (App, LoRaWAN-Parameter, Join).

- [**Seeed SenseCAP S2120 User Guide (PDF)**](https://files.seeedstudio.com/products/SenseCAP/101990961_SenseCAP%20S2120/SenseCAP%20S2120%20LoRaWAN%208-in-1%20Weather%20Station%20User%20Guide.pdf)  
  VollstÃ¤ndiges Benutzerhandbuch als PDF.

- [**Seeed S2120 TTN Decoder (GitHub, JS)**](https://github.com/Seeed-Solution/TTN-Payload-Decoder/blob/master/SenseCAP_S2120_Weather_Station_Decoder.js)  
  JavaScript-Decoder fÃ¼r TTN/ChirpStack zur Auswertung der SenseCAP-Daten.

