---
title: "LoraWan Dragino Doku"
subtitle: "version 0.1"
author: "Chris Reudenbach"
format:
  html:
    toc: true
    toc-depth: 3
    number-sections: false     
    number-depth: 3           
    code-copy: true
    code-link: true
    code-overflow: wrap
    code-fold: true
    highlight-style: github
execute:
  mermaid: true
diagram:
  mermaid:
    engine: kroki
    kroki-url: https://kroki.io
---

# Kurzleitfaden Remote-Kommunikation (nur Port 2, binär)

## Ziel

(Mehrere) Dragino **PS-LB/LS** Sensoren per **TTN** mit **binären Downlinks (Hex)** auf **Port 2** konfigurieren. Im Prinzip muss die folgende Befehlssequenz (für typische Intervalle) via Downlink an den Sensor gesendet werden. Die Reihenfolge in der die Sequenz am Sensor abgearbeiet wird ist **FIFO**. Da die Class A Sensoren nur je Uplink (=Datenpaket) einen Downlink verarbeiten können wird zunächst hochgetaktet damit die Befehlssequenz schneller abgearbeitet werden kann. Konkret sieht das dann wie folgt aus:

-   **TDC** = Sendeintervall (Sekunden)
-   **PROBE=0002** = Wassertiefe-Profil 0–2 m
-   **12 V = 8000 ms** = kurz Sonde speisen

------------------------------------------------------------------------

**1 Minute**

```         
Schritt | Hex       | Zweck
1      | 0100003C  | TDC = 60 s (hochtakten)
2      | 080002    | PROBE = 0002 (0–2 m)
3      | 07031F40  | 12 V = 8000 ms 
4      | 0100003C  | TDC = 60 s (final)
```

**5 Minuten**

```         
Schritt | Hex       | Zweck
1      | 0100003C  | TDC = 60 s (hochtakten)
2      | 080002    | PROBE = 0002 (0–2 m)
3      | 07031F40  | 12 V = 8000 ms 
4      | 0100012C  | TDC = 300 s (5 min)
```

**15 Minuten**

```         
Schritt | Hex       | Zweck
1      | 0100003C  | TDC = 60 s (hochtakten)
2      | 080002    | PROBE = 0002 (0–2 m)
3      | 07031F40  | 12 V = 8000 ms 
4      | 01000384  | TDC = 900 s (15 min)
```

**30 Minuten**

```         
Schritt | Hex       | Zweck
1      | 0100003C  | TDC = 60 s (hochtakten)
2      | 080002    | PROBE = 0002 (0–2 m)
3      | 07031F40  | 12 V = 8000 ms 
4      | 01000708  | TDC = 1800 s (30 min)
```

**60 Minuten**

```         
Schritt | Hex       | Zweck
1      | 0100003C  | TDC = 60 s (hochtakten)
2      | 080002    | PROBE = 0002 (0–2 m)
3      | 07031F40  | 12 V = 8000 ms 
4      | 01000E10  | TDC = 3600 s (60 min)
```

Falls die Sonden **extern** versorgt sind (**sind sie nicht!!**), kann Schritt 3 weggelassen werden, alle anderen Schritte bleiben identisch.

## Wo im Webinterface die Minimal-Sequenz eingegeben wird (TTN/TTS)

Die Sensoren sind im [The Things Stack](https://eu1.cloud.thethings.network/console) angemeldet. Das nennt sich TTN-Console unter wähle oben rechts den Cluster (für Europa eu1) und melde dich an.

**Pfad:** **Applications → *deine App* → End devices → *dein Gerät* → Messaging → Downlink**

**Pro Gerät:**

1.  Bereich **Schedule downlink**:

    -   **FPort**: `2`

    -   **Payload type**: **Bytes**

    -   **Bytes** (Hex ohne Leerzeichen), nacheinander schedulen:

        -   `0100003C` (TDC = 60 s)
        -   `080002` (PROBE = 0002, 0–2 m)
        -   `07031F40` (optional, 12 V 8 s, nur wenn PS-LB speist)
        -   `01000384` (TDC = 900 s = 15 min)

    -   **Confirmed**: an (schadet nicht)

    -   **Schedule** klicken

2.  **Uplink auslösen** (Taste kurz) oder auf Intervall warten – Class A liefert Downlinks jeweils **nach** einem Uplink (FIFO).

    Falls das klemmt: Oben: **Payload formatter → Downlink = None** dann die Sequenz nochmal durchlaufen

## Batch-Script mit per-Gerät-Intervall

Weil das ein Alptram ist hier ein Script das sowohl die zeitintervalle ausrechnet als auch die Befehle im Stapel absendet damit die Kommunikationslimits nicht gebrochen werden:

Als input wird eine CSV-Datei `devices.csv`benötigt die wie folgt aufgebaut ist:

`device_id, interval_min, ext_power`

-   `interval_min`: End-Intervall in Minuten (z. B. 5, 15, 20 …)
-   `ext_power`: `1` = Sonde **extern** versorgt → **ohne** 12 V-Downlink; `0` = PS-LB soll kurz speisen → **mit** 12 V-Downlink

Beispiel:

```         
ps-lb-01,15,0
ps-lb-21,5,0
ps-lb-42,20,0
```

### Script: `set_dragino.sh`

-   Nimmt **nur Hex** als Kommandos, wandelt intern in Base64.
-   Legt pro Gerät **einen** `down/replace` mit bis zu 4 Downlinks (FIFO) ab.
-   End-Intervall kommt aus der CSV (1–255 min unterstützt, typische Werte 5/15/20/30/60).
-  `.env` ist jetzt verpflichtend Den Pfad kannst du überschreiben mit:` ENV_FILE=/custom/.env ./dragino_downlink.sh`

``` bash
#!/usr/bin/env bash
set -euo pipefail
# -e : exit on error
# -u : treat unset variables as errors
# -o pipefail : a pipeline fails if any command within fails

# ==============================================================================
# .env LOADING (REQUIRED)
# - By default expects ./scripts/.env (override with: ENV_FILE=/path/.env ./script.sh)
# - This file must define: TTN_APP_ID, TTN_REGION, TTN_API_KEY
# - We do NOT hardcode secrets in this script.
# ==============================================================================
ENV_FILE="${ENV_FILE:-./scripts/.env}"
if [ -f "$ENV_FILE" ]; then
  set -a            # auto-export variables sourced from the .env
  . "$ENV_FILE"
  set +a
else
  echo "Error: ENV file '$ENV_FILE' not found." >&2
  echo "Please create it and define TTN_APP_ID, TTN_REGION, TTN_API_KEY," >&2
  echo "or run with: ENV_FILE=/absolute/path/to/.env ./dragino_downlink.sh" >&2
  echo "Security note: never commit .env to Git; if a key was exposed, rotate it in TTN Console." >&2
  exit 1
fi

# ==============================================================================
# CONFIG FROM ENV (required: TTN_APP_ID / TTN_REGION / TTN_API_KEY)
# Optional overrides via ENV or .env: CSV, FPORT
# ==============================================================================
APP="${TTN_APP_ID:?TTN_APP_ID is required}"
REGION="${TTN_REGION:?TTN_REGION is required}"          # e.g. eu1
KEY="${TTN_API_KEY:?TTN_API_KEY is required}"            # NNSXS
API="https://${REGION}.cloud.thethings.network/api/v3"

CSV="${CSV:-devices.csv}"                                # CSV format: device_id,interval_min,ext_power
FPORT="${FPORT:-2}"                                      # FPort used by Dragino downlinks

# ==============================================================================
# TOOL CHECKS (hard dependencies)
# ==============================================================================
need(){ command -v "$1" >/dev/null 2>&1 || { echo "Missing dependency: $1" >&2; exit 1; }; }
need xxd
need base64
need curl
need jq
need awk

# ==============================================================================
# HELPERS
# 1) Hex -> base64 (TTN expects base64 in frm_payload)
# 2) Minutes -> seconds -> 3-byte big-endian hex (for TDC command payload)
# ==============================================================================
to_b64(){ printf "%s" "$1" | xxd -r -p | base64; }

tdc_hex_from_minutes(){
  local min="$1"
  local sec=$(( min * 60 ))
  # format as 3-byte big-endian hex (6 uppercase hex chars)
  printf "%06X" "$sec"
}

# ==============================================================================
# FIXED DRAGINO COMMANDS (hex; converted to base64 right before POST)
# Adjust only if your device profile/firmware requires different values.
# ==============================================================================
HEX_PROBE="080002"      # Depth profile 0–2 m
HEX_TDC_60S="0100003C"  # TDC = 60 s (fast phase to quickly drain the queue)
HEX_12V_8S="07031F40"   # 12V pulse = 8000 ms (only used when external PS-LB powers the probe)

# ==============================================================================
# INPUT CSV
# Expected columns (no header needed):
#   device_id,interval_min,ext_power
#   - device_id     : TTN device ID
#   - interval_min  : final target interval in minutes
#   - ext_power     : "0" => also send 12V pulse; anything else => skip 12V pulse
# ==============================================================================
if [ ! -f "$CSV" ]; then
  echo "Error: CSV '$CSV' not found. Expecting 'device_id,interval_min,ext_power' rows." >&2
  exit 1
fi

# ==============================================================================
# MAIN LOOP
# Build a FIFO downlink queue per device and replace (POST /down/replace):
#   1) set TDC=60s (fast phase)
#   2) set measurement profile (PROBE)
#   3) optionally send 12V pulse (if ext_power == 0)
#   4) set final TDC from CSV (minutes -> 3-byte hex)
# Notes:
# - We DO NOT set 'confirmed' or 'priority' here (lean payload).
# - Class A: downlinks are delivered AFTER the next uplink; typically 1 per uplink.
# ==============================================================================
while IFS=, read -r DEV MINUTES EXT; do
  # skip empty lines / comments
  [[ -z "${DEV// }" || "$DEV" =~ ^# ]] && continue

  # trim whitespace
  DEV="$(echo "$DEV" | awk '{$1=$1};1')"
  MINUTES="$(echo "$MINUTES" | awk '{$1=$1};1')"
  EXT="$(echo "$EXT" | awk '{$1=$1};1')"

  # final TDC payload: 01 + 3-byte big-endian seconds
  TDC3=$(tdc_hex_from_minutes "$MINUTES")   # e.g., 15 -> 000384
  HEX_TDC_FINAL="01${TDC3}"

  # convert hex to base64 (what TTN expects in frm_payload)
  P_TDC60=$(to_b64 "$HEX_TDC_60S")
  P_PROBE=$(to_b64 "$HEX_PROBE")
  P_12V8=$(to_b64 "$HEX_12V_8S")
  P_TDCF=$(to_b64 "$HEX_TDC_FINAL")

  echo "== ${DEV} (final interval ${MINUTES} min, ext_power=${EXT}) =="

  # compose downlinks array (no 'confirmed', no 'priority')
  if [[ "$EXT" == "0" ]]; then
    JSON=$(jq -n --arg p1 "$P_TDC60" --arg p2 "$P_PROBE" --arg p3 "$P_12V8" --arg p4 "$P_TDCF" --argjson fp "$FPORT" \
      '{downlinks:[
        {f_port:$fp, frm_payload:$p1},
        {f_port:$fp, frm_payload:$p2},
        {f_port:$fp, frm_payload:$p3},
        {f_port:$fp, frm_payload:$p4}
      ]}')
  else
    JSON=$(jq -n --arg p1 "$P_TDC60" --arg p2 "$P_PROBE" --arg p4 "$P_TDCF" --argjson fp "$FPORT" \
      '{downlinks:[
        {f_port:$fp, frm_payload:$p1},
        {f_port:$fp, frm_payload:$p2},
        {f_port:$fp, frm_payload:$p4}
      ]}')
  fi

  # single API call per device: replace the queue
  HTTP=$(curl -sS -o /tmp/resp.json -w "%{http_code}" \
    -X POST "$API/as/applications/$APP/devices/$DEV/down/replace" \
    -H "Authorization: Bearer $KEY" \
    -H "Content-Type: application/json" \
    -d "$JSON")

  echo "HTTP: $HTTP"
  cat /tmp/resp.json; echo
  [[ "$HTTP" =~ ^2 ]] || { echo "Error while queuing downlinks for $DEV — see response above." >&2; exit 1; }

done < "$CSV"

echo "Note (Class A): downlinks are delivered AFTER the next uplink (usually one downlink per uplink)."
echo "Keep TDC=60s active until each device has drained its queue, then it will switch to the final interval."

```

-   Das Script baut für jedes Gerät die **gleiche Start-Sequenz** (60 s → PROBE → optional externe Stromversorgung) und setzt dann das **End-Intervall aus der CSV**.
-   Unterstützt beliebige Minutenwerte (z. B. 5/15/20).

### Troubleshooting

-   **Downlinks „kommen nicht“** → Es braucht **einen Uplink** (Taste kurz!), Queue FIFO.

-   **Rate-Limit** → nur **ein** `down/replace` pro Gerät; im Batch kleine Pause.

-   **Tiefe bleibt 0** & Uplink zeigt `IDC=0000` → **keine 4–20 mA-Schleife**:

    -   Verdrahtung in Serie über **IDC+ / IDC−** prüfen
    -   Test: `07031F40` + Uplink → **IDC \> 4 mA** oder **VDC \> 0**
    -   A/B-Tausch Sonde ↔ Gerät, um Sensor/Board zu isolieren

-   **Remote-Reset** → `04FF`, danach Sequenz erneut senden.

-   **Statusframe** (zur Kontrolle) → `2601` (nächster Uplink auf FPort 5 zeigt Modell/FW/Band/BAT)
