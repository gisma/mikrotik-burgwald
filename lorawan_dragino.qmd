---
title: "LoraWan Dragino Doku"
subtitle: "version 0.1"
author: "Chris Reudenbach"
format:
  html:
    toc: true
    toc-depth: 3
    number-sections: false     
    number-depth: 3           
    code-copy: true
    code-link: true
    code-overflow: wrap
    code-fold: true
    highlight-style: github
execute:
  mermaid: true
diagram:
  mermaid:
    engine: kroki
    kroki-url: https://kroki.io
---

# Kurzleitfaden Remote-Kommunikation (nur Port 2, binär)

## Ziel

(Mehrere) Dragino **PS-LB/LS** Sensoren per **TTN** mit **binären Downlinks (Hex)** auf **Port 2** konfigurieren. Im Prinzip muss die folgende Befehlssequenz (für typische Intervalle) via Downlink an den Sensor gesendet werden. Die Reihenfolge in der die Sequenz am Sensor abgearbeiet wird ist **FIFO**. Da die Class A Sensoren nur je Uplink (=Datenpaket) einen Downlink verarbeiten können wird zunächst hochgetaktet damit die Befehlssequenz schneller abgearbeitet werden kann. Konkret sieht das dann wie folgt aus:

-   **TDC** = Sendeintervall (Sekunden)
-   **PROBE=0002** = Wassertiefe-Profil 0–2 m
-   **12 V = 8000 ms** = kurz Sonde speisen

------------------------------------------------------------------------

**1 Minute**

```         
Schritt | Hex       | Zweck
1      | 0100003C  | TDC = 60 s (hochtakten)
2      | 080002    | PROBE = 0002 (0–2 m)
3      | 07031F40  | 12 V = 8000 ms 
4      | 0100003C  | TDC = 60 s (final)
```

**5 Minuten**

```         
Schritt | Hex       | Zweck
1      | 0100003C  | TDC = 60 s (hochtakten)
2      | 080002    | PROBE = 0002 (0–2 m)
3      | 07031F40  | 12 V = 8000 ms 
4      | 0100012C  | TDC = 300 s (5 min)
```

**15 Minuten**

```         
Schritt | Hex       | Zweck
1      | 0100003C  | TDC = 60 s (hochtakten)
2      | 080002    | PROBE = 0002 (0–2 m)
3      | 07031F40  | 12 V = 8000 ms 
4      | 01000384  | TDC = 900 s (15 min)
```

**30 Minuten**

```         
Schritt | Hex       | Zweck
1      | 0100003C  | TDC = 60 s (hochtakten)
2      | 080002    | PROBE = 0002 (0–2 m)
3      | 07031F40  | 12 V = 8000 ms 
4      | 01000708  | TDC = 1800 s (30 min)
```

**60 Minuten**

```         
Schritt | Hex       | Zweck
1      | 0100003C  | TDC = 60 s (hochtakten)
2      | 080002    | PROBE = 0002 (0–2 m)
3      | 07031F40  | 12 V = 8000 ms 
4      | 01000E10  | TDC = 3600 s (60 min)
```

Falls die Sonden **extern** versorgt sind (**sind sie nicht!!**), kann Schritt 3 weggelassen werden, alle anderen Schritte bleiben identisch.

## Wo im Webinterface die Minimal-Sequenz eingegeben wird (TTN/TTS)

Die Sensoren sind im [The Things Stack](https://eu1.cloud.thethings.network/console) angemeldet. Das nennt sich TTN-Console unter wähle oben rechts den Cluster (für Europa eu1) und melde dich an.

**Pfad:** **Applications → *deine App* → End devices → *dein Gerät* → Messaging → Downlink**

**Pro Gerät:**

1.  Bereich **Schedule downlink**:

    -   **FPort**: `2`

    -   **Payload type**: **Bytes**

    -   **Bytes** (Hex ohne Leerzeichen), nacheinander schedulen:

        -   `0100003C` (TDC = 60 s)
        -   `080002` (PROBE = 0002, 0–2 m)
        -   `07031F40` (optional, 12 V 8 s, nur wenn PS-LB speist)
        -   `01000384` (TDC = 900 s = 15 min)

    -   **Confirmed**: an (schadet nicht)

    -   **Schedule** klicken

2.  **Uplink auslösen** (Taste kurz) oder auf Intervall warten – Class A liefert Downlinks jeweils **nach** einem Uplink (FIFO).

    Falls das klemmt: Oben: **Payload formatter → Downlink = None** dann die Sequenz nochmal durchlaufen

## Batch-Script mit per-Gerät-Intervall

Weil das ein Alptram ist hier ein Script das sowohl die zeitintervalle ausrechnet als auch die Befehle im Stapel absendet damit die Kommunikationslimits nicht gebrochen werden:

Als input wird eine CSV-Datei `devices.csv`benötigt die wie folgt aufgebaut ist:

`device_id, interval_min, ext_power`

-   `interval_min`: End-Intervall in Minuten (z. B. 5, 15, 20 …)
-   `ext_power`: `1` = Sonde **extern** versorgt → **ohne** 12 V-Downlink; `0` = PS-LB soll kurz speisen → **mit** 12 V-Downlink

Beispiel:

```         
ps-lb-01,15,0
ps-lb-21,5,0
ps-lb-42,20,0
```

### Script: `downlink_hex_replace_map.sh`

-   Nimmt **nur Hex** als Kommandos, wandelt intern in Base64.
-   Legt pro Gerät **einen** `down/replace` mit bis zu 4 Downlinks (FIFO) ab.
-   End-Intervall kommt aus der CSV (1–255 min unterstützt, typische Werte 5/15/20/30/60).

``` bash
#!/usr/bin/env bash
set -euo pipefail

# ===== KONFIG =====
APP="gisma-hydro-testbed"                 # Application-ID
KEY="NNSXS.xxxxx..."                      # Application-API-Key (Write downlink)
API="https://eu1.cloud.thethings.network/api/v3"
CSV="devices.csv"                         # device_id,interval_min,ext_power
FPORT=2

need(){ command -v "$1" >/dev/null 2>&1 || { echo "Fehlt: $1"; exit 1; }; }
need xxd; need base64; need curl; need jq; need awk

# -- Hex-Helper --
to_b64(){ printf "%s" "$1" | xxd -r -p | base64; }

# TDC-Hex aus Minuten berechnen (3-Byte Big-Endian Sekunden)
# Limitation: 1..65535 Sekunden; für unsere Intervalle (1..1440 min) ok.
tdc_hex_from_minutes(){
  local min="$1"
  local sec=$(( min*60 ))
  # in 3 Bytes big-endian verpacken
  printf "%06X" "$sec"
}

# Fixe Hex-Commands
HEX_PROBE="080002"           # Wassertiefe-Profil 0–2 m
HEX_TDC_60S="0100003C"       # TDC=60s (Schnellphase)
HEX_12V_8S="07031F40"        # 12V=8000ms (nur wenn PS-LB speist)

[[ -f "$CSV" ]] || { echo "CSV '$CSV' fehlt."; exit 1; }

# Sanfte Drossel zwischen Geräten
DELAY_BETWEEN_DEV=0.2

while IFS=, read -r DEV MINUTES EXT; do
  # Leerzeilen/Kommentare überspringen
  [[ -z "${DEV// }" || "$DEV" =~ ^# ]] && continue

  # Whitespace trim
  DEV="$(echo "$DEV" | awk '{$1=$1};1')"
  MINUTES="$(echo "$MINUTES" | awk '{$1=$1};1')"
  EXT="$(echo "$EXT" | awk '{$1=$1};1')"

  # End-TDC aus Minuten → Sekunden → 3-Byte Hex → komplettes Setz-Command (01 + 3 Byte)
  TDC3=$(tdc_hex_from_minutes "$MINUTES")      # z.B. 15min -> 000384
  HEX_TDC_FINAL="01${TDC3}"

  # In Base64 umwandeln
  P_TDC60=$(to_b64 "$HEX_TDC_60S")
  P_PROBE=$(to_b64 "$HEX_PROBE")
  P_12V8=$(to_b64 "$HEX_12V_8S")
  P_TDCF=$(to_b64 "$HEX_TDC_FINAL")

  echo "== $DEV (Endintervall ${MINUTES} min, ext_power=${EXT}) =="

  # Downlink-Liste zusammenbauen (FIFO: TDC60 -> PROBE -> optional 12V -> TDCfinal)
  if [[ "$EXT" == "0" ]]; then
    JSON=$(jq -n --arg p1 "$P_TDC60" --arg p2 "$P_PROBE" --arg p3 "$P_12V8" --arg p4 "$P_TDCF" --argjson fp $FPORT \
      '{downlinks:[
        {f_port:$fp, frm_payload:$p1, confirmed:true, priority:"NORMAL"},
        {f_port:$fp, frm_payload:$p2, confirmed:true, priority:"NORMAL"},
        {f_port:$fp, frm_payload:$p3, confirmed:true, priority:"NORMAL"},
        {f_port:$fp, frm_payload:$p4, confirmed:true, priority:"NORMAL"}
      ]}')
  else
    JSON=$(jq -n --arg p1 "$P_TDC60" --arg p2 "$P_PROBE" --arg p4 "$P_TDCF" --argjson fp $FPORT \
      '{downlinks:[
        {f_port:$fp, frm_payload:$p1, confirmed:true, priority:"NORMAL"},
        {f_port:$fp, frm_payload:$p2, confirmed:true, priority:"NORMAL"},
        {f_port:$fp, frm_payload:$p4, confirmed:true, priority:"NORMAL"}
      ]}')
  fi

  # Ein API-Call pro Gerät: down/replace
  HTTP=$(curl -sS -o /tmp/resp.json -w "%{http_code}" \
    -X POST "$API/as/applications/$APP/devices/$DEV/down/replace" \
    -H "Authorization: Bearer $KEY" -H "Content-Type: application/json" \
    -d "$JSON")

  echo "HTTP: $HTTP"
  cat /tmp/resp.json; echo
  [[ "$HTTP" =~ ^2 ]] || { echo "Fehler bei $DEV – siehe oben."; exit 1; }

  sleep "$DELAY_BETWEEN_DEV"
done < "$CSV"

echo "Hinweis: Class A → Downlinks kommen NACH dem nächsten Uplink (FIFO, meist 1 pro Uplink).
Lass TDC=60s aktiv, bis die Queue bei jedem Gerät abgearbeitet ist."
```

-   Das Script baut für jedes Gerät die **gleiche Start-Sequenz** (60 s → PROBE → optional externe Stromversorgung) und setzt dann das **End-Intervall aus der CSV**.
-   Unterstützt beliebige Minutenwerte (z. B. 5/15/20).

### Troubleshooting

-   **Downlinks „kommen nicht“** → Es braucht **einen Uplink** (Taste kurz!), Queue FIFO.

-   **Rate-Limit** → nur **ein** `down/replace` pro Gerät; im Batch kleine Pause.

-   **Tiefe bleibt 0** & Uplink zeigt `IDC=0000` → **keine 4–20 mA-Schleife**:

    -   Verdrahtung in Serie über **IDC+ / IDC−** prüfen
    -   Test: `07031F40` + Uplink → **IDC \> 4 mA** oder **VDC \> 0**
    -   A/B-Tausch Sonde ↔ Gerät, um Sensor/Board zu isolieren

-   **Remote-Reset** → `04FF`, danach Sequenz erneut senden.

-   **Statusframe** (zur Kontrolle) → `2601` (nächster Uplink auf FPort 5 zeigt Modell/FW/Band/BAT)
