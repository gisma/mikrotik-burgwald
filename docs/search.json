[
  {
    "objectID": "live-data.html",
    "href": "live-data.html",
    "title": "Daten (Python-Ausgabe)",
    "section": "",
    "text": "path &lt;- \"data/data.html\"\nif (!file.exists(path)) {\n  cat('&lt;div class=\"callout-note\"&gt;',\n      '&lt;strong&gt;Hinweis:&lt;/strong&gt; &lt;code&gt;data/data.html&lt;/code&gt; wurde noch nicht erzeugt.',\n      'Bitte erst den Python-Job laufen lassen (TTN Pull).',\n      '&lt;/div&gt;')\n} else {\n  htmltools::includeHTML(path)\n}\n\n(Noch keine Daten verf√ºgbar. Die TTN-Pipeline erzeugt diese Seite beim n√§chsten Lauf.)",
    "crumbs": [
      "Home",
      "Daten Vorschau",
      "Live Daten"
    ]
  },
  {
    "objectID": "data/index.html",
    "href": "data/index.html",
    "title": "Daten Repo",
    "section": "",
    "text": "Datei\nGr√∂√üe\nGe√§ndert (UTC)\nBeschreibung\n\n\n\n\nindex.rmarkdown\nindex.rmarkdown\n3.2 KiB\n2025-09-11 19:15:29Z\nDatenablage des Messnetzes (Format je nach Ger√§t/Export).\n\n\ndds75-lb-06_raw.ndjson\ndds75-lb-06_raw.ndjson\n112.1 KiB\n2025-09-11 19:08:41Z\nNDJSON: eine JSON-Zeile pro TTN-Uplink (decoded_payload, rssi/snr, f_port).\n\n\ndds75-lb-07_raw.ndjson\ndds75-lb-07_raw.ndjson\n115.3 KiB\n2025-09-11 19:08:41Z\nNDJSON: eine JSON-Zeile pro TTN-Uplink (decoded_payload, rssi/snr, f_port).\n\n\ndds75-lb-07.parquet\ndds75-lb-07.parquet\n5.7 KiB\n2025-09-11 19:08:41Z\nParquet-Timeseries DDS75-LB: received_at, device_id, distance_cm, temperature, battery, Flags.\n\n\ndds75-lb-04_raw.ndjson\ndds75-lb-04_raw.ndjson\n118.3 KiB\n2025-09-11 19:08:41Z\nNDJSON: eine JSON-Zeile pro TTN-Uplink (decoded_payload, rssi/snr, f_port).\n\n\ndds75-lb-05_raw.ndjson\ndds75-lb-05_raw.ndjson\n114.5 KiB\n2025-09-11 19:08:41Z\nNDJSON: eine JSON-Zeile pro TTN-Uplink (decoded_payload, rssi/snr, f_port).\n\n\ndds75-lb-05.parquet\ndds75-lb-05.parquet\n5.8 KiB\n2025-09-11 19:08:41Z\nParquet-Timeseries DDS75-LB: received_at, device_id, distance_cm, temperature, battery, Flags.\n\n\ndds75-lb-06.parquet\ndds75-lb-06.parquet\n5.3 KiB\n2025-09-11 19:08:41Z\nParquet-Timeseries DDS75-LB: received_at, device_id, distance_cm, temperature, battery, Flags.\n\n\ndds75-lb-02_raw.ndjson\ndds75-lb-02_raw.ndjson\n113.5 KiB\n2025-09-11 19:08:41Z\nNDJSON: eine JSON-Zeile pro TTN-Uplink (decoded_payload, rssi/snr, f_port).\n\n\ndds75-lb-03_raw.ndjson\ndds75-lb-03_raw.ndjson\n107.3 KiB\n2025-09-11 19:08:41Z\nNDJSON: eine JSON-Zeile pro TTN-Uplink (decoded_payload, rssi/snr, f_port).\n\n\ndds75-lb-03.parquet\ndds75-lb-03.parquet\n5.4 KiB\n2025-09-11 19:08:41Z\nParquet-Timeseries DDS75-LB: received_at, device_id, distance_cm, temperature, battery, Flags.\n\n\ndds75-lb-04.parquet\ndds75-lb-04.parquet\n5.6 KiB\n2025-09-11 19:08:41Z\nParquet-Timeseries DDS75-LB: received_at, device_id, distance_cm, temperature, battery, Flags.\n\n\nburgwald-sensecap-01_raw.ndjson\nburgwald-sensecap-01_raw.ndjson\n1.3 MiB\n2025-09-11 19:08:41Z\nNDJSON: eine JSON-Zeile pro TTN-Uplink (decoded_payload, rssi/snr, f_port).\n\n\ndata.html\ndata.html\n133.0 B\n2025-09-11 19:08:41Z\nDatenablage des Messnetzes (Format je nach Ger√§t/Export).\n\n\ndds75-lb-001_raw.ndjson\ndds75-lb-001_raw.ndjson\n200.4 KiB\n2025-09-11 19:08:41Z\nNDJSON: eine JSON-Zeile pro TTN-Uplink (decoded_payload, rssi/snr, f_port).\n\n\ndds75-lb-001.parquet\ndds75-lb-001.parquet\n6.4 KiB\n2025-09-11 19:08:41Z\nParquet-Timeseries DDS75-LB: received_at, device_id, distance_cm, temperature, battery, Flags.\n\n\ndds75-lb-02.parquet\ndds75-lb-02.parquet\n5.5 KiB\n2025-09-11 19:08:41Z\nParquet-Timeseries DDS75-LB: received_at, device_id, distance_cm, temperature, battery, Flags.\n\n\nburgwald-ps-lb-01_raw.ndjson\nburgwald-ps-lb-01_raw.ndjson\n142.6 KiB\n2025-09-11 19:08:41Z\nNDJSON: eine JSON-Zeile pro TTN-Uplink (decoded_payload, rssi/snr, f_port).\n\n\nburgwald-sensecap-01.parquet\nburgwald-sensecap-01.parquet\n32.4 KiB\n2025-09-11 19:08:41Z\nParquet-Timeseries SenseCAP: received_at, temperature, humidity, pressure_hpa, illumination, ggf. UV/Wind/Regen.\n\n\nburgwald-ps-lb-01.parquet\nburgwald-ps-lb-01.parquet\n6.2 KiB\n2025-09-11 19:08:41Z\nParquet-Timeseries PS-LB: received_at, water_cm/pressure_kpa/_mpa, idc_input_ma, vdc_input_v, battery."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Hydro-Messnetz Burgwald",
    "section": "",
    "text": "Im Burgwald in Hessen wird ein hydrologisches Echtzeit-Monitoring eingerichtet, das kontinuierlich Daten zu Niederschlag, Bodenfeuchte, Grundwasser und Abfluss liefert. Sensoren erfassen die relevanten Gr√∂√üen und √ºbertragen sie per Funk oder Mobilfunk in zentrale Datenbanken. So k√∂nnen Ver√§nderungen in Moor- und Quellbereichen zeitnah erkannt und f√ºr Wasserhaushaltsanalysen genutzt werden. Diese Webseite dient der technischen und inhaltlichen Dokumentation des Monitorings und stellt perspektivisch auch die erhobenen Datens√§tze f√ºr Forschung, Praxis und √ñffentlichkeit zur Verf√ºgung.",
    "crumbs": [
      "Home",
      "√úber...",
      "Hydro-Messnetz Burgwald"
    ]
  },
  {
    "objectID": "lorawan_doku.html",
    "href": "lorawan_doku.html",
    "title": "LoraWan Doku",
    "section": "",
    "text": "Hier folgt eine basale Anleitung f√ºr den Betrieb eines MikroTik-LoRaWAN-Gateways (RBwAPR-2nD) √ºber WLAN mit TTN (EU1) sowie der Einbindung der Sensoren Dragino PS-LB, Dragino DDS-75LB und Seeed SenseCAP S2120. Die konkreten Decoder sind nicht enthalte aber auf dem Gateway bereits aktiv. Zus√§tzlich werden praxistaugliche Wege zum Dauerbetrieb (Storage, MQTT‚ÜíCSV/DB, InfluxDB/Grafana) und No-Code-Speicherung (Webhooks) skizziert. Beispiele und Snippets sind so gehalten, dass sie direkt √ºbernommen werden k√∂nnen.",
    "crumbs": [
      "Home",
      "LoRaWAN",
      "Anleitung"
    ]
  },
  {
    "objectID": "lorawan_doku.html#script-hochladen",
    "href": "lorawan_doku.html#script-hochladen",
    "title": "LoraWan Doku",
    "section": "1.1 Script hochladen",
    "text": "1.1 Script hochladen\n\nIn WinBox ‚Üí Files: Setup-Datei gisma_base2.rsc einfach per Drag&Drop auf das Ger√§t laden. WinBox Download (MikroTik)",
    "crumbs": [
      "Home",
      "LoRaWAN",
      "Anleitung"
    ]
  },
  {
    "objectID": "lorawan_doku.html#script-importieren",
    "href": "lorawan_doku.html#script-importieren",
    "title": "LoraWan Doku",
    "section": "1.2 Script importieren",
    "text": "1.2 Script importieren\n\nIn WinBox ‚Üí New Terminal ausf√ºhren:\n\n  /import file-name=gisma_base2.rsc",
    "crumbs": [
      "Home",
      "LoRaWAN",
      "Anleitung"
    ]
  },
  {
    "objectID": "lorawan_doku.html#funktion-testen",
    "href": "lorawan_doku.html#funktion-testen",
    "title": "LoraWan Doku",
    "section": "1.3 Funktion testen",
    "text": "1.3 Funktion testen\n\nWLAN/DHCP:\n\n  /interface wireless monitor wlan1 once\n  /ip dhcp-client print detail\n  /ping 8.8.8.8 count=4\n\nLoRa (falls enthalten):\n\n  /lora print detail\n  /tool sniffer quick port=1700",
    "crumbs": [
      "Home",
      "LoRaWAN",
      "Anleitung"
    ]
  },
  {
    "objectID": "lorawan_doku.html#grundlagen-mikrotik-konnektivit√§t-mac-zugriff-und-hotspot-einstellungen",
    "href": "lorawan_doku.html#grundlagen-mikrotik-konnektivit√§t-mac-zugriff-und-hotspot-einstellungen",
    "title": "LoraWan Doku",
    "section": "1.4 Grundlagen MikroTik-Konnektivit√§t, MAC-Zugriff und Hotspot-Einstellungen",
    "text": "1.4 Grundlagen MikroTik-Konnektivit√§t, MAC-Zugriff und Hotspot-Einstellungen\n\n1.4.1 Hardware-Aufbau\n\nMikroTik RBwAPR-2nD mit Netzteil/PoE versorgen.\nEthernet vom PC/Laptop an ether1 des MikroTik stecken.\nOptional: LoRa-Antenne montieren und fest verschrauben.\n\n\n\n1.4.2 Erstverbindung per WinBox (Layer-2 / MAC)\n\nWinBox starten ‚Üí Neighbors: RBwAPR sollte automatisch erscheinen.\nVerbinden √ºber MAC Address (funktioniert ohne IP).\nLogin: ab Werk admin (ggf. ohne Passwort) ‚Üí bei erster Anmeldung Passwort setzen.\nBei √§lteren QuickSet-Resten: System ‚Üí Reset Configuration (ohne Default-Skripte), danach erneut per MAC verbinden.\n\n\n\n1.4.3 Hotspot-/WLAN-Voraussetzungen\n\nBand: 2,4 GHz (802.11b/g/n). Station-Pseudobridge ist bei 5 GHz oft nicht zuverl√§ssig.\nSicherheitsmodus: WPA2-PSK (empfohlen), Kennwort ohne Sonderf√§lle.\nSSID: sichtbar, statischer Name (keine Auto-Umschaltung).\nKanalbreite: 20 MHz gen√ºgt; Auto-Kanal ist ok.\nCaptive Portal: deaktivieren. Portale blockieren Headless-Ger√§te.\nMAC-Filter: falls aktiv, MAC von wlan1 freigeben (siehe Interfaces ‚Üí wlan1).\nDHCP am Hotspot: aktiv, ausreichend Adressbereich (z. B. 192.168.1.100‚Äì200).\nInternet-Durchleitung (NAT) im Hotspot aktiv lassen.\n\n\n\n1.4.4 WLAN-Client (GUI-Weg, WinBox)\n\nWireless ‚Üí Security Profiles\n\nWPA2-PSK mit Kennwort anlegen/√§ndern.\n\nWireless ‚Üí wlan1\n\nMode: station-pseudobridge\n\nBand: 2ghz-b/g/n\n\nSSID: Hotspot-SSID eintragen\n\nApply, dann Enable.\n\nBridge\n\nBridge ‚Üí + bridgeLocal anlegen.\n\nBridge ‚Üí Ports: wlan1 und ether1 zur bridgeLocal hinzuf√ºgen.\n\nDHCP-Client\n\nIP ‚Üí DHCP Client ‚Üí +\n\nInterface: bridgeLocal, Enabled.\n\n\nDNS (optional)\n\nIP ‚Üí DNS: Public Resolver (z. B. 8.8.8.8, 1.1.1.1), ‚ÄûAllow Remote Requests‚Äú aktivieren.\n\n\n\n\n1.4.5 Kontrolle & Umstieg auf IP-Zugriff\n\nIP-Bezug pr√ºfen: IP ‚Üí DHCP Client zeigt ‚Äûbound‚Äú mit zugewiesener IP.\nRouting/Internet testen: New Terminal ‚Üí /ping 8.8.8.8 count=4\nDanach in WinBox statt √ºber MAC √ºber die IP verbinden (stabiler, schneller).\n\n\n\n1.4.6 Tests (Terminal, minimal)\n/interface wireless monitor wlan1 once\n/ip dhcp-client print detail\n/ping 8.8.8.8 count=4\n/ip route print\n/ip dns print\nüëâ Damit ist die Konfiguration in einem Rutsch aufgespielt.",
    "crumbs": [
      "Home",
      "LoRaWAN",
      "Anleitung"
    ]
  },
  {
    "objectID": "lorawan_doku.html#topologie-und-begriffe",
    "href": "lorawan_doku.html#topologie-und-begriffe",
    "title": "LoraWan Doku",
    "section": "2.1 Topologie und Begriffe",
    "text": "2.1 Topologie und Begriffe\nKurz√ºberblick √ºber alle Bausteine (Sensoren, Gateway, Netzwerk, TTN, Decoder) und wie sie zusammenspielen. Begriffe werden so eingef√ºhrt, dass die folgenden Schritte leichter nachvollziehbar sind.\n\n2.1.1 Gesamtbild\nEine End-to-End-Skizze vom Sensor (LoRaWAN) bis zur Datennutzung (Speicher/Visualisierung). Hilft, die Rolle jeder Komponente zu verstehen.\n\n\n\n\n\n%%{init: {'themeVariables': { 'fontSize': '12px' }}}%%\nflowchart TB\n  A[\"Sensor&lt;br/&gt;(LoRaWAN, EU868)\"]\n  B[\"LoRa-Gateway&lt;br/&gt;MikroTik RBwAPR-2nD\"]\n  C[\"WLAN-Hotspot&lt;br/&gt;(Internet)\"]\n  D[\"TTN (EU1)\"]\n  E[\"Decoder&lt;br/&gt;(in TTN Application)\"]\n  F[\"Ablage / Visualisierung&lt;br/&gt;(Storage / MQTT / DB / Grafana / No-Code)\"]\n  A --&gt; B --&gt; C --&gt; D --&gt; E --&gt; F\n\n\n\n\n\n\n\n\n\n2.1.2 MikroTik als WLAN-Client\nDer MikroTik wird als WLAN-Station betrieben, nicht als Access Point. So h√§ngt er sich in ein vorhandenes WLAN ein und leitet LoRaWAN-Pakete ins Internet.\n\nDer MikroTik arbeitet nicht als Access Point, sondern als Station im WLAN (vergleichbar mit einem Laptop).\nDer Modus station-pseudobridge sorgt daf√ºr, dass WLAN und Ethernet im selben Layer-2-Segment erscheinen (Broadcast-Domain geteilt).\n\n\n\n2.1.3 Bridge (bridgeLocal)\nEine Layer‚Äë2‚ÄëBridge, die wlan1 und ether1 zu einem logischen Switch verbindet. Der DHCP-Client sitzt auf der Bridge, damit die IP f√ºr beide Ports gilt.\n\nDie Bridge b√ºndelt Interfaces zu einem logischen Switch (hier: wlan1 + ether1).\nDHCP-Client h√§ngt auf der Bridge und bezieht die IP vom Hotspot.\n\n\n\n2.1.4 ‚ÄûAlte Reste‚Äú\nWerkseinstellungen/QuickSet legen oft Regeln an, die im Client-Betrieb st√∂ren. Dieser Abschnitt erkl√§rt, was entfernt bzw. nicht ben√∂tigt wird.\n\nWerkseinstellungen/QuickSet hinterlassen oft DHCP-Server/NAT/Firewall-Regeln, die im Client-Betrieb st√∂ren k√∂nnen.\nNach Reset wird nur das N√∂tige konfiguriert (WLAN-Client, Bridge, DHCP-Client, DNS).\n\n\n\n2.1.5 Sensoren/Decoder (ohne Details)\n√úberblick, welche Ger√§te eingebunden werden und wo deren Decoder liegen (TTN Application oder per Device-Override).\n\nDragino PS-LB und Dragino DDS-75LB werden identisch (OTAA) aufgenommen; Decoder unterscheiden sich, sind aber in der TTN-Application bereits aktiv.\nSenseCAP S2120 nutzt propriet√§re Payloads (typisch FPort 199); der Decoder ist in der Application hinterlegt.\nVerwaltung: Application ‚Üí Payload formatters (Uplink); auf Wunsch device-spezifisch via Device-Override.",
    "crumbs": [
      "Home",
      "LoRaWAN",
      "Anleitung"
    ]
  },
  {
    "objectID": "lorawan_doku.html#mikrotik-soll-konfiguration-wlan-bridge-lora",
    "href": "lorawan_doku.html#mikrotik-soll-konfiguration-wlan-bridge-lora",
    "title": "LoraWan Doku",
    "section": "2.2 MikroTik ‚Äì Soll-Konfiguration (WLAN & Bridge & LoRa)",
    "text": "2.2 MikroTik ‚Äì Soll-Konfiguration (WLAN & Bridge & LoRa)\nSchritt‚Äëf√ºr‚ÄëSchritt‚ÄëKonfiguration des MikroTik: WLAN-Client, Bridge, IP/DNS und LoRa‚ÄëGateway‚ÄëWeiterleitung zu TTN EU1.\n\nDie folgenden Snippets setzen die bekannte funktionierende Basis um (WLAN-Client auf SSID ‚ÄûGISMA-NET‚Äú, WPA2-PSK, Pseudobridge, TTN EU1/UDP, EU-868).\n\n\n2.2.1 WLAN-Security\nSicherheitsprofil f√ºr WPA/WPA2‚ÄëPSK. Hinterlegt Schl√ºssel und Cipher.\n/interface wireless security-profiles set [find default=yes] \\\n    mode=dynamic-keys \\\n    authentication-types=wpa-psk,wpa2-psk \\\n    unicast-ciphers=tkip,aes-ccm \\\n    group-ciphers=tkip,aes-ccm \\\n    supplicant-identity=MikroTik \\\n    wpa-pre-shared-key=36171669 \\\n    wpa2-pre-shared-key=36171669\n\n\n2.2.2 WLAN als Client (Pseudobridge)\nVersetzt wlan1 in den Station‚ÄëModus mit Pseudobridge, um im gleichen Layer‚Äë2 wie der Hotspot zu sein.\n/interface wireless set [find default-name=wlan1] \\\n    band=2ghz-b/g/n \\\n    wireless-protocol=802.11 \\\n    mode=station-pseudobridge \\\n    ssid=GISMA-NET \\\n    frequency=auto \\\n    disabled=no\n\n\n2.2.3 Bridge + Ports\nErstellt bridgeLocal und f√ºgt wlan1 und ether1 als Ports hinzu.\n/interface bridge add name=bridgeLocal\n/interface bridge port add bridge=bridgeLocal interface=wlan1\n/interface bridge port add bridge=bridgeLocal interface=ether1\n\n\n2.2.4 IP-Bezug & DNS\nAktiviert einen DHCP‚ÄëClient auf der Bridge und setzt Resolver f√ºr DNS.\n/ip dhcp-client add interface=bridgeLocal disabled=no\n/ip dns set allow-remote-requests=yes servers=8.8.8.8,1.1.1.1\n\n\n2.2.5 LoRa ‚Äì TTN EU1 (Semtech UDP) & EU-868\nAktiviert das eingebaute LoRa‚ÄëGateway, stellt EU‚Äë868 ein und konfiguriert den Semtech‚ÄëUDP‚ÄëForwarder zu TTN EU1.\n/lora disable 0\n/lora set 0 servers=\"TTN V3 (eu1)\" channel-plan=eu-868 \\\n    network=public forward=crc-valid,crc-error\n/lora enable 0\nPr√ºfung:\nSchnelle Checks: LoRa‚ÄëStatus und ob UDP‚ÄëPakete auf Port 1700 rausgehen.\n/lora print detail\n/tool sniffer quick port=1700",
    "crumbs": [
      "Home",
      "LoRaWAN",
      "Anleitung"
    ]
  },
  {
    "objectID": "lorawan_doku.html#winboxterminal-diagnoseleitfaden",
    "href": "lorawan_doku.html#winboxterminal-diagnoseleitfaden",
    "title": "LoraWan Doku",
    "section": "2.3 WinBox/Terminal ‚Äì Diagnoseleitfaden",
    "text": "2.3 WinBox/Terminal ‚Äì Diagnoseleitfaden\nSammlung typischer Diagnose‚ÄëBefehle, um WLAN, IP‚ÄëVergabe, Routing und LoRa‚ÄëWeiterleitung zu pr√ºfen.\n\n2.3.1 WLAN & IP\nBefehle zum Scannen/√úberwachen des WLANs und zum Pr√ºfen der IP‚ÄëKonfiguration/Konnektivit√§t.\n\nWLAN-Scan:\n\n  /interface wireless scan wlan1\n\nMonitor des Clients (Status, Kanal, Rauschpegel):\n\n  /interface wireless monitor wlan1\n\nDHCP-Client-Status:\n\n  /ip dhcp-client print detail\n\nRouting:\n\n  /ip route print\n\nKonnektivit√§tstest:\n\n  /ping 8.8.8.8\n\n\n2.3.2 Bridge/Ports\nDruckt Bridge und Port‚ÄëZugeh√∂rigkeiten, um Fehlverdrahtungen auszuschlie√üen.\n/interface bridge print\n/interface bridge port print\n\n\n2.3.3 LoRa-Gateway\nPr√ºft LoRa‚ÄëGateway‚ÄëParameter (EUI, Server, Plan) und ob Forwarder‚ÄëTraffic sichtbar ist.\n\nStatus/EUI/Server/Plan:\n\n  /lora print detail\n\nUDP-Forwarding sichtbar?\n\n  /tool sniffer quick port=1700\n\n\n2.3.4 Export/Sicherung\nExportiert die Konfiguration textuell (Backup der Einstellungen) bzw. erstellt ein bin√§res Voll‚ÄëBackup.\n\nTerse-Export (menschenlesbar):\n\n  /export terse\n\nBinary-Backup (voll):\n\n  /system backup save name=running.backup",
    "crumbs": [
      "Home",
      "LoRaWAN",
      "Anleitung"
    ]
  },
  {
    "objectID": "lorawan_doku.html#ttn-konsole-gateway-application-ger√§te",
    "href": "lorawan_doku.html#ttn-konsole-gateway-application-ger√§te",
    "title": "LoraWan Doku",
    "section": "2.4 TTN-Konsole ‚Äì Gateway, Application, Ger√§te",
    "text": "2.4 TTN-Konsole ‚Äì Gateway, Application, Ger√§te\nSchritte in der TTN‚ÄëKonsole: Gateway registrieren, Application anlegen, Ger√§te per OTAA hinzuf√ºgen und Decoder pr√ºfen.\n\n2.4.1 Gateway\nRegistrierung des Gateways in TTN inkl. Cluster und Frequency‚ÄëPlan.\n\nRegistrierung mit Gateway-EUI (siehe /lora print detail).\nCluster: eu1.cloud.thethings.network.\nFrequency Plan: EU_863_870_TTN.\n\n\n\n2.4.2 Application & Ger√§te (OTAA)\nGer√§te anlegen (OTAA‚ÄëDaten), Decoder aktivieren/pr√ºfen und Live‚ÄëDaten kontrollieren.\n\nApplication (z. B. gisma-hydro-testbed) vorhanden.\nGer√§te hinzuf√ºgen (PS-LB, DDS-75LB, S2120): DevEUI, JoinEUI/AppEUI, AppKey (jeweils 16 Byte Hex).\nDecoder sind aktiv (Application-Ebene bzw. Device-Override).\nKontrolle unter End device ‚Üí Live data: Uplinks sichtbar, decoded_payload gef√ºllt.\n\n\n\n\n\n\n\nDatenablage ‚Äì einfache Wege ohne eigenen Server\n\n\n\n\n\n\n2.5 Datenablage ‚Äì einfache Wege ohne eigenen Server\nDrei niedrigschwellige Optionen, um Daten ohne eigene Server‚ÄëSoftware zu speichern (Storage, MQTT‚ÜíDatei, Webhooks).\n\n2.5.1 TTS-Storage (eingebaut, ‚Äúkein Server n√∂tig‚Äù)\nTTN‚Äëinterner Speicher mit einfachem HTTP‚ÄëAbruf (NDJSON). Ideal f√ºr erste Tests/Archivierung.\nAktivierung: Application ‚Üí Integrations ‚Üí Storage ‚Üí Enable.\nAbruf (NDJSON):\nAPP_ID=\"gisma-hydro-testbed\"\nREGION=\"eu1\"\nAPI_KEY=\"NNSXS.***api_key***\"\n\ncurl -s -H \"Authorization: Bearer $API_KEY\" \\\n\"https://${REGION}.cloud.thethings.network/api/v3/as/applications/${APP_ID}/packages/storage/uplink_message?limit=100\" \\\n&gt; uplinks.ndjson\nNach CSV destillieren (allgemein):\njq -r '\n  .end_device_ids.device_id as $id\n  | .received_at as $ts\n  | .uplink_message.f_port as $fport\n  | (.uplink_message.decoded_payload // {}) as $dec\n  | [$ts,$id,$fport,($dec|tostring)]\n  | @csv\n' uplinks.ndjson &gt; uplinks.csv\nHinweis: Speicherfrist je nach Tarif begrenzt ‚Üí regelm√§√üig abholen.\n\n\n2.5.2 MQTT ‚Üí Datei/CSV (ohne Programmierung)\nAbonnieren des TTN‚ÄëMQTT‚ÄëFeeds und direkte Umwandlung in CSV mit jq.\nAbonnieren:\nAPP_ID=\"gisma-hydro-testbed\"\nREGION=\"eu1\"\nAPI_KEY=\"NNSXS.***api_key***\"\n\nmosquitto_sub -h \"${REGION}.cloud.thethings.network\" -p 8883 \\\n  -u \"${APP_ID}\" -P \"${API_KEY}\" --cafile /etc/ssl/certs/ca-certificates.crt \\\n  -t \"v3/${APP_ID}@ttn/devices/+/up\" &gt; live.ndjson\nOn-the-fly CSV:\nmosquitto_sub ... | jq -r '\n  .end_device_ids.device_id as $id\n  | .received_at as $ts\n  | .uplink_message.f_port as $fport\n  | (.uplink_message.decoded_payload // {}) as $dec\n  | [$ts,$id,$fport,($dec|tostring)]\n  | @csv\n' &gt;&gt; live.csv\n\n\n2.5.3 No-Code via Webhooks\nWeiterleitung der Uplinks per HTTP an Dienste wie Make.com, n8n oder Zapier, die ohne Programmierung in Tabellen/DBs schreiben.\n\nApplication ‚Üí Integrations ‚Üí Webhooks ‚Üí Add ‚Üí ‚ÄûCustom‚Äú oder Vorlage.\nZiel-URL eines Make.com, n8n Cloud oder Zapier Flows eintragen.\nJSON in Google Sheets, Airtable, Notion oder S3/Datenbank speichern.\n\n\n\n\n\n2.6 Dauerbetrieb ‚Äì robuste Pipelines (MQTT‚ÜíDB, Grafana)\nProduktionsreife Wege, um kontinuierlich Daten zu sammeln, in eine Zeitreihendatenbank zu schreiben und mit Grafana zu visualisieren.\n\n2.6.1 Minimal-Python (MQTT‚ÜíCSV/JSON)\nKleines Python‚ÄëSkript mit paho-mqtt, das Uplinks liest und als CSV/JSON speichert.\n# mqtt_to_csv.py\nimport ssl, json, csv\nfrom paho.mqtt.client import Client\n\nAPP_ID  = \"gisma-hydro-testbed\"\nREGION  = \"eu1\"\nAPI_KEY = \"NNSXS.***api_key***\"\nTOPIC   = f\"v3/{APP_ID}@ttn/devices/+/up\"\nBROKER  = f\"{REGION}.cloud.thethings.network\"\n\ndef on_connect(c,u,f,rc):\n    c.subscribe(TOPIC, qos=0)\n\ndef on_message(c,u,msg):\n    up = json.loads(msg.payload.decode())\n    ts  = up.get(\"received_at\")\n    dev = up.get(\"end_device_ids\",{}).get(\"device_id\")\n    fpt = up.get(\"uplink_message\",{}).get(\"f_port\")\n    dec = up.get(\"uplink_message\",{}).get(\"decoded_payload\", {})\n    with open(\"uplinks.csv\",\"a\",newline=\"\") as f:\n        csv.writer(f).writerow([ts,dev,fpt,json.dumps(dec,ensure_ascii=False)])\n\ncli = Client(client_id=APP_ID)\ncli.username_pw_set(APP_ID, API_KEY)\ncli.tls_set(cert_reqs=ssl.CERT_REQUIRED)\ncli.on_connect = on_connect\ncli.on_message = on_message\ncli.connect(BROKER, 8883, keepalive=60)\ncli.loop_forever()\nStart:\npip install paho-mqtt\npython mqtt_to_csv.py\n\n\n2.6.2 InfluxDB v2 + Grafana (Docker-Variante)\nStack aus InfluxDB (Zeitreihendatenbank), Telegraf (Ingest/Parsing) und Grafana (Dashboards) als Docker‚ÄëCompose.\ndocker-compose.yml (Beispiel, lokal)\nversion: \"3.8\"\nservices:\n  influxdb:\n    image: influxdb:2\n    ports: [ \"8086:8086\" ]\n    volumes: [ \"influx:/var/lib/influxdb2\" ]\n    environment:\n      - DOCKER_INFLUXDB_INIT_MODE=setup\n      - DOCKER_INFLUXDB_INIT_USERNAME=admin\n      - DOCKER_INFLUXDB_INIT_PASSWORD=adminpass\n      - DOCKER_INFLUXDB_INIT_ORG=gisma\n      - DOCKER_INFLUXDB_INIT_BUCKET=lorawan\n  telegraf:\n    image: telegraf:1.29\n    depends_on: [ influxdb ]\n    volumes:\n      - ./telegraf.conf:/etc/telegraf/telegraf.conf:ro\n  grafana:\n    image: grafana/grafana:10\n    ports: [ \"3000:3000\" ]\n    volumes: [ \"grafana:/var/lib/grafana\" ]\nvolumes:\n  influx:\n  grafana:\ntelegraf.conf (MQTT‚ÜíInfluxDB Line Protocol)\n[agent]\n  omit_hostname = true\n\n# TTN MQTT input\n[[inputs.mqtt_consumer]]\n  servers = [\"ssl://eu1.cloud.thethings.network:8883\"]\n  topics  = [\"v3/gisma-hydro-testbed@ttn/devices/+/up\"]\n  username = \"gisma-hydro-testbed\"\n  password = \"NNSXS.***api_key***\"\n  data_format = \"json\"\n  json_time_key = \"received_at\"\n  json_time_format = \"2006-01-02T15:04:05Z07:00\"\n  # Felder extrahieren\n  json_string_fields = [\"uplink_message.decoded_payload\"]\n\n  # Umformung per tagexclude/fieldpass kann nach Bedarf erg√§nzt werden\n\n# InfluxDB v2 output\n[[outputs.influxdb_v2]]\n  urls = [\"http://influxdb:8086\"]\n  token = \"admin:adminpass\"      # bei Influx v2 Setup eigenen Token verwenden\n  organization = \"gisma\"\n  bucket = \"lorawan\"\nGrafana:\nVisualisierungsschicht. In Grafana die InfluxDB‚ÄëDatenquelle setzen und Panels f√ºr relevante Messreihen anlegen.\n\nDatenquelle InfluxDB v2 auf http://influxdb:8086, Org/Bucket/Token setzen.\nDashboard erstellen; z. B. Messungen pressure_cmH2O, distance_cm, battery, temperature (abh√§ngig von Decoderfeldern in decoded_payload).\nAlternativ: TTN ‚Üí InfluxDB Cloud per Webhook-Vorlage (Konsole ‚Üí Integrations ‚Üí Webhooks ‚Üí InfluxDB Cloud).",
    "crumbs": [
      "Home",
      "LoRaWAN",
      "Anleitung"
    ]
  },
  {
    "objectID": "lorawan_doku.html#datenablage-einfache-wege-ohne-eigenen-server",
    "href": "lorawan_doku.html#datenablage-einfache-wege-ohne-eigenen-server",
    "title": "LoraWan Doku",
    "section": "2.5 Datenablage ‚Äì einfache Wege ohne eigenen Server",
    "text": "2.5 Datenablage ‚Äì einfache Wege ohne eigenen Server\nDrei niedrigschwellige Optionen, um Daten ohne eigene Server‚ÄëSoftware zu speichern (Storage, MQTT‚ÜíDatei, Webhooks).\n\n2.5.1 TTS-Storage (eingebaut, ‚Äúkein Server n√∂tig‚Äù)\nTTN‚Äëinterner Speicher mit einfachem HTTP‚ÄëAbruf (NDJSON). Ideal f√ºr erste Tests/Archivierung.\nAktivierung: Application ‚Üí Integrations ‚Üí Storage ‚Üí Enable.\nAbruf (NDJSON):\nAPP_ID=\"gisma-hydro-testbed\"\nREGION=\"eu1\"\nAPI_KEY=\"NNSXS.***api_key***\"\n\ncurl -s -H \"Authorization: Bearer $API_KEY\" \\\n\"https://${REGION}.cloud.thethings.network/api/v3/as/applications/${APP_ID}/packages/storage/uplink_message?limit=100\" \\\n&gt; uplinks.ndjson\nNach CSV destillieren (allgemein):\njq -r '\n  .end_device_ids.device_id as $id\n  | .received_at as $ts\n  | .uplink_message.f_port as $fport\n  | (.uplink_message.decoded_payload // {}) as $dec\n  | [$ts,$id,$fport,($dec|tostring)]\n  | @csv\n' uplinks.ndjson &gt; uplinks.csv\nHinweis: Speicherfrist je nach Tarif begrenzt ‚Üí regelm√§√üig abholen.\n\n\n2.5.2 MQTT ‚Üí Datei/CSV (ohne Programmierung)\nAbonnieren des TTN‚ÄëMQTT‚ÄëFeeds und direkte Umwandlung in CSV mit jq.\nAbonnieren:\nAPP_ID=\"gisma-hydro-testbed\"\nREGION=\"eu1\"\nAPI_KEY=\"NNSXS.***api_key***\"\n\nmosquitto_sub -h \"${REGION}.cloud.thethings.network\" -p 8883 \\\n  -u \"${APP_ID}\" -P \"${API_KEY}\" --cafile /etc/ssl/certs/ca-certificates.crt \\\n  -t \"v3/${APP_ID}@ttn/devices/+/up\" &gt; live.ndjson\nOn-the-fly CSV:\nmosquitto_sub ... | jq -r '\n  .end_device_ids.device_id as $id\n  | .received_at as $ts\n  | .uplink_message.f_port as $fport\n  | (.uplink_message.decoded_payload // {}) as $dec\n  | [$ts,$id,$fport,($dec|tostring)]\n  | @csv\n' &gt;&gt; live.csv\n\n\n2.5.3 No-Code via Webhooks\nWeiterleitung der Uplinks per HTTP an Dienste wie Make.com, n8n oder Zapier, die ohne Programmierung in Tabellen/DBs schreiben.\n\nApplication ‚Üí Integrations ‚Üí Webhooks ‚Üí Add ‚Üí ‚ÄûCustom‚Äú oder Vorlage.\nZiel-URL eines Make.com, n8n Cloud oder Zapier Flows eintragen.\nJSON in Google Sheets, Airtable, Notion oder S3/Datenbank speichern.",
    "crumbs": [
      "Home",
      "LoRaWAN",
      "Anleitung"
    ]
  },
  {
    "objectID": "lorawan_doku.html#dauerbetrieb-robuste-pipelines-mqttdb-grafana",
    "href": "lorawan_doku.html#dauerbetrieb-robuste-pipelines-mqttdb-grafana",
    "title": "LoraWan Doku",
    "section": "2.6 Dauerbetrieb ‚Äì robuste Pipelines (MQTT‚ÜíDB, Grafana)",
    "text": "2.6 Dauerbetrieb ‚Äì robuste Pipelines (MQTT‚ÜíDB, Grafana)\nProduktionsreife Wege, um kontinuierlich Daten zu sammeln, in eine Zeitreihendatenbank zu schreiben und mit Grafana zu visualisieren.\n\n2.6.1 Minimal-Python (MQTT‚ÜíCSV/JSON)\nKleines Python‚ÄëSkript mit paho-mqtt, das Uplinks liest und als CSV/JSON speichert.\n# mqtt_to_csv.py\nimport ssl, json, csv\nfrom paho.mqtt.client import Client\n\nAPP_ID  = \"gisma-hydro-testbed\"\nREGION  = \"eu1\"\nAPI_KEY = \"NNSXS.***api_key***\"\nTOPIC   = f\"v3/{APP_ID}@ttn/devices/+/up\"\nBROKER  = f\"{REGION}.cloud.thethings.network\"\n\ndef on_connect(c,u,f,rc):\n    c.subscribe(TOPIC, qos=0)\n\ndef on_message(c,u,msg):\n    up = json.loads(msg.payload.decode())\n    ts  = up.get(\"received_at\")\n    dev = up.get(\"end_device_ids\",{}).get(\"device_id\")\n    fpt = up.get(\"uplink_message\",{}).get(\"f_port\")\n    dec = up.get(\"uplink_message\",{}).get(\"decoded_payload\", {})\n    with open(\"uplinks.csv\",\"a\",newline=\"\") as f:\n        csv.writer(f).writerow([ts,dev,fpt,json.dumps(dec,ensure_ascii=False)])\n\ncli = Client(client_id=APP_ID)\ncli.username_pw_set(APP_ID, API_KEY)\ncli.tls_set(cert_reqs=ssl.CERT_REQUIRED)\ncli.on_connect = on_connect\ncli.on_message = on_message\ncli.connect(BROKER, 8883, keepalive=60)\ncli.loop_forever()\nStart:\npip install paho-mqtt\npython mqtt_to_csv.py\n\n\n2.6.2 InfluxDB v2 + Grafana (Docker-Variante)\nStack aus InfluxDB (Zeitreihendatenbank), Telegraf (Ingest/Parsing) und Grafana (Dashboards) als Docker‚ÄëCompose.\ndocker-compose.yml (Beispiel, lokal)\nversion: \"3.8\"\nservices:\n  influxdb:\n    image: influxdb:2\n    ports: [ \"8086:8086\" ]\n    volumes: [ \"influx:/var/lib/influxdb2\" ]\n    environment:\n      - DOCKER_INFLUXDB_INIT_MODE=setup\n      - DOCKER_INFLUXDB_INIT_USERNAME=admin\n      - DOCKER_INFLUXDB_INIT_PASSWORD=adminpass\n      - DOCKER_INFLUXDB_INIT_ORG=gisma\n      - DOCKER_INFLUXDB_INIT_BUCKET=lorawan\n  telegraf:\n    image: telegraf:1.29\n    depends_on: [ influxdb ]\n    volumes:\n      - ./telegraf.conf:/etc/telegraf/telegraf.conf:ro\n  grafana:\n    image: grafana/grafana:10\n    ports: [ \"3000:3000\" ]\n    volumes: [ \"grafana:/var/lib/grafana\" ]\nvolumes:\n  influx:\n  grafana:\ntelegraf.conf (MQTT‚ÜíInfluxDB Line Protocol)\n[agent]\n  omit_hostname = true\n\n# TTN MQTT input\n[[inputs.mqtt_consumer]]\n  servers = [\"ssl://eu1.cloud.thethings.network:8883\"]\n  topics  = [\"v3/gisma-hydro-testbed@ttn/devices/+/up\"]\n  username = \"gisma-hydro-testbed\"\n  password = \"NNSXS.***api_key***\"\n  data_format = \"json\"\n  json_time_key = \"received_at\"\n  json_time_format = \"2006-01-02T15:04:05Z07:00\"\n  # Felder extrahieren\n  json_string_fields = [\"uplink_message.decoded_payload\"]\n\n  # Umformung per tagexclude/fieldpass kann nach Bedarf erg√§nzt werden\n\n# InfluxDB v2 output\n[[outputs.influxdb_v2]]\n  urls = [\"http://influxdb:8086\"]\n  token = \"admin:adminpass\"      # bei Influx v2 Setup eigenen Token verwenden\n  organization = \"gisma\"\n  bucket = \"lorawan\"\nGrafana:\nVisualisierungsschicht. In Grafana die InfluxDB‚ÄëDatenquelle setzen und Panels f√ºr relevante Messreihen anlegen.\n\nDatenquelle InfluxDB v2 auf http://influxdb:8086, Org/Bucket/Token setzen.\nDashboard erstellen; z. B. Messungen pressure_cmH2O, distance_cm, battery, temperature (abh√§ngig von Decoderfeldern in decoded_payload).\nAlternativ: TTN ‚Üí InfluxDB Cloud per Webhook-Vorlage (Konsole ‚Üí Integrations ‚Üí Webhooks ‚Üí InfluxDB Cloud).",
    "crumbs": [
      "Home",
      "LoRaWAN",
      "Anleitung"
    ]
  },
  {
    "objectID": "lorawan_doku.html#betriebshilfen-auto-heal-checks",
    "href": "lorawan_doku.html#betriebshilfen-auto-heal-checks",
    "title": "LoraWan Doku",
    "section": "2.7 Betriebshilfen (Auto-Heal, Checks)",
    "text": "2.7 Betriebshilfen (Auto-Heal, Checks)\nZusatzfunktionen f√ºr stabilen Dauerbetrieb: automatischer WLAN‚ÄëReconnect und korrekte Systemzeit.\n\n2.7.1 Netwatch (WLAN neu verbinden bei Ausfall)\n√úberwacht einen Zielhost und startet wlan1 neu, wenn keine Verbindung besteht.\n/tool netwatch add host=8.8.8.8 interval=60s timeout=5s \\\n    up-script=\"\" \\\n    down-script=\"/interface wireless disable wlan1; :delay 2s; /interface wireless enable wlan1\"\n\n\n2.7.2 NTP & Zeitzone (Logs mit korrekter Uhrzeit)\nStellt Zeitzone und NTP‚ÄëServer ein, damit Logs/Zeitstempel stimmen.\n/system clock set time-zone-name=Europe/Berlin\n/system ntp client set enabled=yes primary-ntp=1.1.1.1 secondary-ntp=8.8.8.8",
    "crumbs": [
      "Home",
      "LoRaWAN",
      "Anleitung"
    ]
  },
  {
    "objectID": "lorawan_doku.html#sensecap-besonderheiten-ohne-decoder-code",
    "href": "lorawan_doku.html#sensecap-besonderheiten-ohne-decoder-code",
    "title": "LoraWan Doku",
    "section": "2.8 SenseCAP-Besonderheiten (ohne Decoder-Code)",
    "text": "2.8 SenseCAP-Besonderheiten (ohne Decoder-Code)\nHinweise zu Pairing, FPorts und Decoder‚ÄëEinsatz f√ºr den SenseCAP S2120.\n\nPairing/BT-PIN: h√§ufig 000000.\nDevEUI/JoinEUI/AppKey: auf Label, App oder Herstellerportal.\nFPort: typischerweise 199.\nIn TTN Ger√§t anlegen (OTAA) ‚Üí Live Data pr√ºfen ‚Üí decoded_payload wird angezeigt (Decoder ist bereits aktiv).\nBei fehlender Decodierung: Application-Level Decoder pr√ºfen; falls mehrere Hersteller parallel verwendet werden, device-spezifische Overrides setzen.",
    "crumbs": [
      "Home",
      "LoRaWAN",
      "Anleitung"
    ]
  },
  {
    "objectID": "lorawan_doku.html#dragino-ps-lb-dds-75lb-ohne-decoder-code",
    "href": "lorawan_doku.html#dragino-ps-lb-dds-75lb-ohne-decoder-code",
    "title": "LoraWan Doku",
    "section": "2.9 Dragino PS-LB & DDS-75LB (ohne Decoder-Code)",
    "text": "2.9 Dragino PS-LB & DDS-75LB (ohne Decoder-Code)\nKurzanleitung f√ºr die Aufnahme per OTAA und Decoder‚ÄëKontrolle der Dragino‚ÄëGer√§te.\n\nBeide √ºber OTAA identisch aufnehmen (DevEUI/JoinEUI/AppKey).\nDecoder unterscheiden sich (Druck vs.¬†Distanz) ‚Äì bereits aktiv.\nKontrolle via Live Data; Werte erscheinen im decoded_payload.\nTypischer FPort 2 (Herstellerdoku beachten).",
    "crumbs": [
      "Home",
      "LoRaWAN",
      "Anleitung"
    ]
  },
  {
    "objectID": "lorawan_doku.html#faqs-troubleshooting",
    "href": "lorawan_doku.html#faqs-troubleshooting",
    "title": "LoraWan Doku",
    "section": "2.10 FAQs & Troubleshooting",
    "text": "2.10 FAQs & Troubleshooting\nKurze Checkliste typischer Fehlerbilder und ihrer Ursachen.\n\nUplinks kommen nicht in TTN an: /lora print detail (Enabled?), /tool sniffer quick port=1700 (UDP-Traffic?), /ip dhcp-client print (IP bekommen?), /ping 8.8.8.8.\nWLAN sichtbar, aber keine IP: Bridge-Ports korrekt? DHCP-Client auf bridgeLocal? WPA-Key/SSID korrekt? monitor wlan1 zeigt ‚Äûsearching-for-network‚Äú ‚Üí Kanal/Entfernung pr√ºfen.\nDecoder greift nicht: FPort pr√ºfen; Application-Decoder vs.¬†Device-Override; f√ºr SenseCAP meist Port 199.\nSpeicherung/Visualisierung fehlt: Storage aktivieren oder MQTT‚ÜíCSV/DB/Grafana implementieren (siehe Kapitel 5 & 6).\n\n\n\n2.10.1 To-Do-Leitfaden\nMinimalliste, um schnell von ‚ÄûGer√§t online‚Äú zu ‚ÄûDaten gesichert und sichtbar‚Äú zu kommen.\n\nTTN Storage aktivieren und per HTTP + jq regelm√§√üig ziehen (Archiv/CSV).\nF√ºr Live-Dashboards MQTT ‚Üí InfluxDB ‚Üí Grafana (Docker-Stack) oder Webhook ‚Üí InfluxDB Cloud/Datacake/Ubidots.\nNetwatch auf dem MikroTik setzen (WLAN-Selbstheilung).\nBinary-Backup auf dem MikroTik anlegen und extern sichern.",
    "crumbs": [
      "Home",
      "LoRaWAN",
      "Anleitung"
    ]
  },
  {
    "objectID": "lorawan_doku.html#anmerkungen",
    "href": "lorawan_doku.html#anmerkungen",
    "title": "LoraWan Doku",
    "section": "2.11 Anmerkungen",
    "text": "2.11 Anmerkungen\nErg√§nzende Hinweise zur Konfiguration und zum Betrieb (EU‚Äë868, Semtech‚ÄëUDP, Datenpfade) in kompakter Form.\n\nDie Decoder f√ºr PS-LB, DDS-75LB und SenseCAP S2120 sind in der TTN-Application hinterlegt und aktiv.\nDer MikroTik arbeitet im WLAN-Client/Pseudobridge-Modus, erh√§lt IP per DHCP auf bridgeLocal und forwardet LoRa-Pakete via Semtech-UDP (Port 1700) an TTN EU1 mit EU-868 Frequency-Plan.\nDaten k√∂nnen √ºber Storage/MQTT/Webhook ohne eigenen Server gespeichert und mit Grafana visualisiert werden.",
    "crumbs": [
      "Home",
      "LoRaWAN",
      "Anleitung"
    ]
  },
  {
    "objectID": "lorawan_doku.html#downloads-handb√ºcher",
    "href": "lorawan_doku.html#downloads-handb√ºcher",
    "title": "LoraWan Doku",
    "section": "2.12 Downloads & Handb√ºcher",
    "text": "2.12 Downloads & Handb√ºcher\n\nWinBox Download (MikroTik)\nOffizielle Seite zum Herunterladen von WinBox (Windows/Linux mit Wine).\nMikroTik RouterOS LoRa Dokumentation\nMikroTik-Doku zu LoRaWAN, Forwarding-Protokoll und Frequency Plans.\n\n\n\nDragino Wiki (√úbersicht)\nZentrale Dokumentation und Manuals f√ºr alle Dragino-Ger√§te.\nDragino Decoder Repository (GitHub)\nSammlung offizieller Payload-Decoder f√ºr End-Nodes (z. B. PS-LB, DDS-75LB).\n\n\n\nSeeed SenseCAP S2120 Getting Started (Wiki)\nSchritt-f√ºr-Schritt-Anleitung zur Inbetriebnahme (App, LoRaWAN-Parameter, Join).\nSeeed SenseCAP S2120 User Guide (PDF)\nVollst√§ndiges Benutzerhandbuch als PDF.\nSeeed S2120 TTN Decoder (GitHub, JS)\nJavaScript-Decoder f√ºr TTN/ChirpStack zur Auswertung der SenseCAP-Daten.",
    "crumbs": [
      "Home",
      "LoRaWAN",
      "Anleitung"
    ]
  }
]