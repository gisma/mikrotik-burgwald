---
title: "Daten Repo"
format:  html
# 
---


## Allgmeine Formate im Repo

**NDJSON** und **Parquet** sind beides Datenformate, die sich gut ergänzen:

* **NDJSON** (Newline Delimited JSON) speichert Ereignisse zeilenweise als JSON-Objekte.
  → Ideal für **Streaming und APIs**, weil jede Zeile ein eigenständiger Datensatz ist, der sofort verarbeitet werden kann.
  → Lässt sich mit Tools wie `jq`, `pandas.read_json(lines=True)` oder `jsonlite::stream_in()` direkt auswerten.

* **Parquet** ist ein **spaltenorientiertes, binäres Format** für große Datenmengen.
  → Optimiert für **Analysen und Abfragen**, sehr platzsparend und schnell.
  → Standard in Big-Data-Systemen (Spark, Hadoop, BigQuery, DuckDB, GDAL/GeoParquet).

Typischer Workflow: **NDJSON für die rohe, zeilenweise Speicherung eingehender Sensordaten** → später in **Parquet für effiziente Archivierung und Analyse** konvertieren.


### Sensoren
* DDS75-LB (dds75-lb-*.parquet): Zeitreihen eines Ultraschall-Pegelsensors mit distance_cm (bzw. Distance_mm), temperature (DS18B20), battery sowie optionalen Flags (interrupt_flag, sensor_flag).
* PS-LB (burgwald-ps-lb-*.parquet): Zeitreihen eines 4–20-mA/Pressure-Sensors mit water_cm bzw. pressure_kpa/_mpa, zusätzlich idc_input_ma, vdc_input_v, battery und digitalen Eingangsflags.
* SenseCAP Wetterstation (burgwald-sensecap-*.parquet): Zeitreihen mit temperature, humidity, pressure_hpa, illumination sowie ggf. uv_index, wind_speed, wind_dir, rainfall.


<div id="data-list">Lade Datenliste …</div>

<div id="data-list">Lade Datenliste …</div>

<script>
(function(){
  const mount = document.getElementById("data-list");
  const url   = "/data/index.json?v=" + Date.now(); // Cache-Buster

  function humanSize(n){
    const u=["B","KiB","MiB","GiB","TiB"];
    let i=0, f=Number(n)||0;
    while(f>=1024 && i<u.length-1){ f/=1024; i++; }
    return `${f.toFixed(f<10&&i>0?1:0)} ${u[i]}`;
  }
  function fmtDate(ts){
    try { return new Date(ts*1000).toISOString().replace('T',' ').replace('Z','Z'); }
    catch { return ""; }
  }

  fetch(url).then(r=>{
    if(!r.ok) throw new Error(r.status+" "+r.statusText);
    return r.json();
  }).then(items=>{
    if(!Array.isArray(items) || items.length===0){
      mount.innerHTML = "<em>(Keine passenden Dateien gefunden)</em>";
      return;
    }
    const css = `<style>
      #data-list table{width:100%;border-collapse:collapse}
      #data-list th,#data-list td{padding:.45rem .6rem;border:1px solid #ddd;text-align:left}
      #data-list th{background:#f7f7f7}
      @media (prefers-color-scheme: dark){
        #data-list th{background:#222;color:#eee}
        #data-list th,#data-list td{border-color:#333}
      }
    </style>`;
    const head = `
      <thead><tr>
        <th>Datei</th><th>Größe</th><th>Typ</th><th>Letzte Änderung (UTC)</th>
      </tr></thead>`;
    const body = items.map(it=>{
      const href = `/data/${encodeURIComponent(it.name)}`;
      return `<tr>
        <td><a href="${href}">${it.name}</a></td>
        <td>${humanSize(it.size)}</td>
        <td>${it.type||""}</td>
        <td>${fmtDate(it.mtime||0)}</td>
      </tr>`;
    }).join("");
    mount.innerHTML = `${css}<table>${head}<tbody>${body}</tbody></table>`;
  }).catch(err=>{
    console.error(err);
    mount.innerHTML = `<div style="color:#b00">Konnte /data/index.json nicht laden: ${String(err.message||err)}</div>`;
  });
})();
</script>
