{
  "hash": "22457b5a465c57929b6db042aedd8401",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Daten\"\nformat: html\nengine: knitr\nexecute:\n  echo: false\n  eval: true\n---\n\n\n\n\nBASE_URL <- \" https://gisma.github.io/mikrotik-burgwald/data\"\n\n\nroot <- file.path(here::here(), \"data\")\n\nnaturalsize <- function(bytes) {\n  units <- c(\"B\",\"KiB\",\"MiB\",\"GiB\",\"TiB\")\n  i <- 1; sz <- as.numeric(bytes)\n  while (sz >= 1024 && i < length(units)) { sz <- sz/1024; i <- i+1 }\n  sprintf(\"%.1f %s\", sz, units[i])\n}\n\nfiles <- list.files(root, all.files = FALSE, full.names = TRUE, no.. = TRUE)\nfiles <- files[basename(files) != \"index.qmd\" & file.exists(files) & !dir.exists(files)]\n\nif (length(files) == 0) {\n  cat(\"(Keine Dateien gefunden)\")\n} else {\n  info <- file.info(files)\n  # Namen und absoluter URL (URL-encodiert)\n  names <- basename(files)\n  urls  <- paste0(BASE_URL, \"/\", utils::URLencode(names, reserved = TRUE))\n\n  df <- data.frame(\n    Datei = sprintf(\"[%s](%s)\", names, urls),\n    Größe = vapply(info$size, naturalsize, character(1)),\n    `Geändert (UTC)` = format(as.POSIXct(info$mtime, tz = \"UTC\"), \"%Y-%m-%d %H:%M:%SZ\"),\n    check.names = FALSE\n  )\n  knitr::kable(df, format = \"html\", table.attr = 'class=\"table table-sm\"')\n}\n\ndescribe_file <- function(name) {\n  n <- tolower(name)\n  ext <- sub(\"^.*\\\\.\", \"\", n)\n  if (grepl(\"^dds75-lb-.*\\\\.parquet$\", n))\n    return(\"Parquet-Timeseries DDS75-LB: received_at, device_id, distance_cm, temperature, battery, Flags.\")\n  if (grepl(\"^burgwald-ps-lb-.*\\\\.parquet$\", n))\n    return(\"Parquet-Timeseries PS-LB: received_at, water_cm/pressure_kpa/_mpa, idc_input_ma, vdc_input_v, battery.\")\n  if (grepl(\"^burgwald-sensecap-.*\\\\.parquet$\", n))\n    return(\"Parquet-Timeseries SenseCAP: received_at, temperature, humidity, pressure_hpa, illumination, ggf. UV/Wind/Regen.\")\n  if (ext == \"parquet\")\n    return(\"Parquet: received_at, device_id, f_port, rssi, snr sowie sensortypische Messspalten.\")\n  if (ext == \"ndjson\")\n    return(\"NDJSON: eine JSON-Zeile pro TTN-Uplink inkl. decoded_payload, rssi/snr, f_port.\")\n  if (ext == \"csv\")\n    return(\"CSV: Tabellendaten mit received_at (UTC) und normalisierten Messfeldern; Kopfzeile vorhanden.\")\n  return(\"Datenablage des Messnetzes (Format je nach Gerät/Export).\")\n}\n\n# … beim Erstellen der Tabelle:\ndf <- data.frame(\n  Datei = sprintf(\"[%s](%s)\", names, urls),\n  Größe = vapply(info$size, naturalsize, character(1)),\n  `Geändert (UTC)` = format(as.POSIXct(info$mtime, tz = \"UTC\"), \"%Y-%m-%d %H:%M:%SZ\"),\n  Beschreibung = vapply(names, describe_file, character(1)),\n  check.names = FALSE\n)\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}